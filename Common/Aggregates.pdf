%!PS-Adobe-3.0
%%Title: Aggregates.c
%%For: gary
%%Creator: VIM - Vi IMproved 7.4 (2013 Aug 10)
%%CreationDate: Fri Jan 15 09:57:12 2016
%%DocumentData: Clean8Bit
%%Orientation: Portrait
%%Pages: (atend)
%%PageOrder: Ascend
%%BoundingBox: 59 49 564 800
%%DocumentMedia: A4 595 842 0 () ()
%%DocumentNeededResources: font Courier
%%+ font Courier-Bold
%%+ font Courier-Oblique
%%+ font Courier-BoldOblique
%%DocumentSuppliedResources: procset VIM-Prolog 1.4 1
%%+ encoding VIM-latin1 1.0 0
%%Requirements: duplex collate color
%%EndComments
%%BeginDefaults
%%PageResources: font Courier
%%+ font Courier-Bold
%%+ font Courier-Oblique
%%+ font Courier-BoldOblique
%%PageMedia: A4
%%EndDefaults
%%BeginProlog
%%BeginResource: procset VIM-Prolog
%%BeginDocument: /usr/share/vim/vim74/print/prolog.ps
%!PS-Adobe-3.0 Resource-ProcSet
%%Title: VIM-Prolog
%%Version: 1.4 1
%%EndComments
% Editing of this file is NOT RECOMMENDED.  You run a very good risk of causing
% all PostScript printing from VIM failing if you do.  PostScript is not called
% a write-only language for nothing!
/packedarray where not{userdict begin/setpacking/pop load def/currentpacking
false def end}{pop}ifelse/CP currentpacking def true setpacking
/bd{bind def}bind def/ld{load def}bd/ed{exch def}bd/d/def ld
/db{dict begin}bd/cde{currentdict end}bd
/T true d/F false d
/SO null d/sv{/SO save d}bd/re{SO restore}bd
/L2 systemdict/languagelevel 2 copy known{get exec}{pop pop 1}ifelse 2 ge d
/m/moveto ld/s/show ld /ms{m s}bd /g/setgray ld/r/setrgbcolor ld/sp{showpage}bd
/gs/gsave ld/gr/grestore ld/cp/currentpoint ld
/ul{gs UW setlinewidth cp UO add 2 copy newpath m 3 1 roll add exch lineto
stroke gr}bd
/bg{gs r cp BO add 4 -2 roll rectfill gr}bd
/sl{90 rotate 0 exch translate}bd
L2{
/sspd{mark exch{setpagedevice}stopped cleartomark}bd
/nc{1 db/NumCopies ed cde sspd}bd
/sps{3 db/Orientation ed[3 1 roll]/PageSize ed/ImagingBBox null d cde sspd}bd
/dt{2 db/Tumble ed/Duplex ed cde sspd}bd
/c{1 db/Collate ed cde sspd}bd
}{
/nc{/#copies ed}bd
/sps{statusdict/setpage get exec}bd
/dt{statusdict/settumble 2 copy known{get exec}{pop pop pop}ifelse
statusdict/setduplexmode 2 copy known{get exec}{pop pop pop}ifelse}bd
/c{pop}bd
}ifelse
/ffs{findfont exch scalefont d}bd/sf{setfont}bd
/ref{1 db findfont dup maxlength dict/NFD ed{exch dup/FID ne{exch NFD 3 1 roll
put}{pop pop}ifelse}forall/Encoding findresource dup length 256 eq{NFD/Encoding
3 -1 roll put}{pop}ifelse NFD dup/FontType get 3 ne{/CharStrings}{/CharProcs}
ifelse 2 copy known{2 copy get dup maxlength dict copy[/questiondown/space]{2
copy known{2 copy get 2 index/.notdef 3 -1 roll put pop exit}if pop}forall put
}{pop pop}ifelse dup NFD/FontName 3 -1 roll put NFD definefont pop end}bd
CP setpacking
(\004)cvn{}bd
% vim:ff=unix:
%%EOF
%%EndDocument
%%EndResource
%%BeginResource: encoding VIM-latin1
%%BeginDocument: /usr/share/vim/vim74/print/latin1.ps
%!PS-Adobe-3.0 Resource-Encoding
%%Title: VIM-latin1
%%Version: 1.0 0
%%EndComments
/VIM-latin1[
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/space /exclam /quotedbl /numbersign /dollar /percent /ampersand /quotesingle
/parenleft /parenright /asterisk /plus /comma /minus /period /slash
/zero /one /two /three /four /five /six /seven
/eight /nine /colon /semicolon /less /equal /greater /question
/at /A /B /C /D /E /F /G
/H /I /J /K /L /M /N /O
/P /Q /R /S /T /U /V /W
/X /Y /Z /bracketleft /backslash /bracketright /asciicircum /underscore
/grave /a /b /c /d /e /f /g
/h /i /j /k /l /m /n /o
/p /q /r /s /t /u /v /w
/x /y /z /braceleft /bar /braceright /asciitilde /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/space /exclamdown /cent /sterling /currency /yen /brokenbar /section
/dieresis /copyright /ordfeminine /guillemotleft /logicalnot /hyphen /registered /macron
/degree /plusminus /twosuperior /threesuperior /acute /mu /paragraph /periodcentered
/cedilla /onesuperior /ordmasculine /guillemotright /onequarter /onehalf /threequarters /questiondown
/Agrave /Aacute /Acircumflex /Atilde /Adieresis /Aring /AE /Ccedilla
/Egrave /Eacute /Ecircumflex /Edieresis /Igrave /Iacute /Icircumflex /Idieresis
/Eth /Ntilde /Ograve /Oacute /Ocircumflex /Otilde /Odieresis /multiply
/Oslash /Ugrave /Uacute /Ucircumflex /Udieresis /Yacute /Thorn /germandbls
/agrave /aacute /acircumflex /atilde /adieresis /aring /ae /ccedilla
/egrave /eacute /ecircumflex /edieresis /igrave /iacute /icircumflex /idieresis
/eth /ntilde /ograve /oacute /ocircumflex /otilde /odieresis /divide
/oslash /ugrave /uacute /ucircumflex /udieresis /yacute /thorn /ydieresis]
/Encoding defineresource pop
% vim:ff=unix:
%%EOF
%%EndDocument
%%EndResource
%%EndProlog
%%BeginSetup
595 842 0 sps
1 nc
T F dt
T c
%%IncludeResource: font Courier
/_F0 /VIM-latin1 /Courier ref
/F0 10 /_F0 ffs
%%IncludeResource: font Courier-Bold
/_F1 /VIM-latin1 /Courier-Bold ref
/F1 10 /_F1 ffs
%%IncludeResource: font Courier-Oblique
/_F2 /VIM-latin1 /Courier-Oblique ref
/F2 10 /_F2 ffs
%%IncludeResource: font Courier-BoldOblique
/_F3 /VIM-latin1 /Courier-BoldOblique ref
/F3 10 /_F3 ffs
/UO -1 d
/UW 0.5 d
/BO -2.5 d
%%EndSetup
%%Page: 1 1
%%BeginPageSetup
sv
0 g
F0 sf
%%EndPageSetup
F1 sf
(Aggregates.c                                                                  Page 1)59.5 792.4 ms
0.376 0 0.376 r
(#include )59.5 772.4 ms
F0 sf
0 0.251 0 r
(<stdio.h>)s
F1 sf
0.376 0 0.376 r
(#include )59.5 762.4 ms
F0 sf
0 0.251 0 r
(<stdlib.h>)s
F1 sf
0.376 0 0.376 r
(#include )59.5 752.4 ms
F0 sf
0 0.251 0 r
(<string.h>)s
F1 sf
0.376 0 0.376 r
(#include )59.5 742.4 ms
F0 sf
0 0.251 0 r
(<stdbool.h>)s
F1 sf
0.376 0 0.376 r
(#include )59.5 732.4 ms
F0 sf
0 0.251 0 r
(<math.h>)s
F1 sf
0.376 0 0.376 r
(#include )59.5 722.4 ms
F0 sf
0 0.251 0 r
("AnalysisTools.h")s
(void)59.5 702.4 ms
0 g
( ErrorHelp\()s
0 0.251 0 r
(char)s
0 g
( cmd[)s
0 0.251 0 r
(50)s
0 g
(]\) { )s
F1 sf
0.251 0.251 0 r
(//{{{)s
F0 sf
0 g
(  fprintf\()59.5 692.4 ms
0 0.251 0 r
(stderr)s
0 g
(, )s
0 0.251 0 r
("Usage:)s
0.376 0 0.376 r
(\\n)s
0 0.251 0 r
(")s
0 g
(\);)s
(  fprintf\()59.5 682.4 ms
0 0.251 0 r
(stderr)s
0 g
(, )s
0 0.251 0 r
("   )s
0.376 0 0.376 r
(%s)s
0 0.251 0 r
( <input.vcf> <distance> <contacts> ")s
0 g
(, cmd\);)s
(  fprintf\()59.5 672.4 ms
0 0.251 0 r
(stderr)s
0 g
(, )s
0 0.251 0 r
("<output.agg> <type names> <options>)s
0.376 0 0.376 r
(\\n\\n)s
0 0.251 0 r
(")s
0 g
(\);)s
(  fprintf\()59.5 652.4 ms
0 0.251 0 r
(stderr)s
0 g
(, )s
0 0.251 0 r
("   <input.vcf>       input filename \(vcf format\))s
0.376 0 0.376 r
(\\n)s
0 0.251 0 r
(")s
0 g
(\);)s
(  fprintf\()59.5 642.4 ms
0 0.251 0 r
(stderr)s
0 g
(, )s
0 0.251 0 r
("   <distance>        minimum distance for contact for aggregate c)s
(heck)59.5 632.4 ms
0.376 0 0.376 r
(\\n)s
0 0.251 0 r
(")s
0 g
(\);)s
(  fprintf\()59.5 622.4 ms
0 0.251 0 r
(stderr)s
0 g
(, )s
0 0.251 0 r
("   <contacts>        minimum number of contacts for aggregate che)s
(ck)59.5 612.4 ms
0.376 0 0.376 r
(\\n)s
0 0.251 0 r
(")s
0 g
(\);)s
(  fprintf\()59.5 602.4 ms
0 0.251 0 r
(stderr)s
0 g
(, )s
0 0.251 0 r
("   <output.agg>      output filename \(agg format\))s
0.376 0 0.376 r
(\\n)s
0 0.251 0 r
(")s
0 g
(\);)s
(  fprintf\()59.5 592.4 ms
0 0.251 0 r
(stderr)s
0 g
(, )s
0 0.251 0 r
("   <type names>      names of bead types to use for closeness cal)s
(culation)59.5 582.4 ms
0.376 0 0.376 r
(\\n)s
0 0.251 0 r
(")s
0 g
(\);)s
(  fprintf\()59.5 572.4 ms
0 0.251 0 r
(stderr)s
0 g
(, )s
0 0.251 0 r
("   <options>)s
0.376 0 0.376 r
(\\n)s
0 0.251 0 r
(")s
0 g
(\);)s
(  fprintf\()59.5 562.4 ms
0 0.251 0 r
(stderr)s
0 g
(, )s
0 0.251 0 r
("      -i <name>      use input .vsf file different from dl_meso.v)s
(sf)59.5 552.4 ms
0.376 0 0.376 r
(\\n)s
0 0.251 0 r
(")s
0 g
(\);)s
(  fprintf\()59.5 542.4 ms
0 0.251 0 r
(stderr)s
0 g
(, )s
0 0.251 0 r
("      -b <name>      file containing bond alternatives to FIELD)s
0.376 0 0.376 r
(\\n)s
0 0.251 0 r
(")59.5 532.4 ms
0 g
(\);)s
(  fprintf\()59.5 522.4 ms
0 0.251 0 r
(stderr)s
0 g
(, )s
0 0.251 0 r
("      -v             verbose output)s
0.376 0 0.376 r
(\\n)s
0 0.251 0 r
(")s
0 g
(\);)s
(  fprintf\()59.5 512.4 ms
0 0.251 0 r
(stderr)s
0 g
(, )s
0 0.251 0 r
("      -V             verbose output with comments from input .vcf)s
( file)59.5 502.4 ms
0.376 0 0.376 r
(\\n)s
0 0.251 0 r
(")s
0 g
(\);)s
(  fprintf\()59.5 492.4 ms
0 0.251 0 r
(stderr)s
0 g
(, )s
0 0.251 0 r
("      -h             print this help and exit)s
0.376 0 0.376 r
(\\n)s
0 0.251 0 r
(")s
0 g
(\);)s
(} )59.5 482.4 ms
F1 sf
0.251 0.251 0 r
(//}}})s
F0 sf
0 0.251 0 r
(void)59.5 462.4 ms
0 g
( CalculateAggregates\(Aggregate **Aggregate, Counts *Counts, )s
0 0.251 0 r
(int)s
0 g
( sqdist, )s
0 0.251 0 r
(int)s
0 g
( cont)s
(acts, )59.5 452.4 ms
F1 sf
0.251 0.251 0 r
(//{{{)s
F0 sf
0 g
(                         Vector BoxLength, BeadType *BeadType, Bead **Bead,)59.5 442.4 ms
(                         MoleculeType *MoleculeType, Molecule *Molecule\) {)59.5 432.4 ms
(  )59.5 412.4 ms
F1 sf
0.251 0.251 0 r
(// zeroize //{{{)s
F0 sf
0 g
(  \(*Counts\).Aggregates = )59.5 402.4 ms
0 0.251 0 r
(0)s
0 g
(;)s
(  )59.5 392.4 ms
0 0.125 0.251 r
(for)s
0 g
( \()s
0 0.251 0 r
(int)s
0 g
( i = )s
0 0.251 0 r
(0)s
0 g
(; i < \(*Counts\).Molecules; i++\) {)s
(    \(*Aggregate\)[i].nMolecules = )59.5 382.4 ms
0 0.251 0 r
(0)s
0 g
(;)s
(    \(*Aggregate\)[i].nBeads = )59.5 372.4 ms
0 0.251 0 r
(0)s
0 g
(;)s
(    \(*Aggregate\)[i].nMonomers = )59.5 362.4 ms
0 0.251 0 r
(0)s
0 g
(;)s
(  } )59.5 352.4 ms
F1 sf
0.251 0.251 0 r
(//}}})s
F0 sf
0 g
(  )59.5 332.4 ms
F1 sf
0.251 0.251 0 r
(// allocate & zeroize contact[][] \(triangular matrix\) and moved array //{{{)s
F0 sf
0 g
(  )59.5 322.4 ms
0 0.251 0 r
(int)s
0 g
( **contact = malloc\(\(*Counts\).Molecules*)s
0 0.125 0.251 r
(sizeof)s
0 g
(\()s
0 0.251 0 r
(int)s
0 g
( *\)\);)s
(  )59.5 312.4 ms
0 0.251 0 r
(int)s
0 g
( *moved = malloc\(\(*Counts\).Molecules*)s
0 0.125 0.251 r
(sizeof)s
0 g
(\()s
0 0.251 0 r
(int)s
0 g
(\)\);)s
(  )59.5 302.4 ms
0 0.125 0.251 r
(for)s
0 g
( \()s
0 0.251 0 r
(int)s
0 g
( i = )s
0 0.251 0 r
(0)s
0 g
(; i < \(*Counts\).Molecules; i++\) {)s
(    contact[i] = malloc\(\(i+)59.5 292.4 ms
0 0.251 0 r
(1)s
0 g
(\)*)s
0 0.125 0.251 r
(sizeof)s
0 g
(\()s
0 0.251 0 r
(int)s
0 g
(\)\);)s
(  })59.5 282.4 ms
(  )59.5 262.4 ms
F1 sf
0.251 0.251 0 r
(// zeroize arrays)s
F0 sf
0 g
(  )59.5 252.4 ms
0 0.125 0.251 r
(for)s
0 g
( \()s
0 0.251 0 r
(int)s
0 g
( i = )s
0 0.251 0 r
(0)s
0 g
(; i < \(*Counts\).Molecules; i++\) {)s
(    moved[i] = )59.5 242.4 ms
0 0.251 0 r
(0)s
0 g
(;)s
(    )59.5 232.4 ms
0 0.125 0.251 r
(for)s
0 g
( \()s
0 0.251 0 r
(int)s
0 g
( j = )s
0 0.251 0 r
(0)s
0 g
(; j < i; j++\) )s
F1 sf
0.251 0.251 0 r
(/* j == i is really not needed */)s
F0 sf
0 g
(      contact[i][j] = )59.5 222.4 ms
0 0.251 0 r
(0)s
0 g
(;)s
(  } )59.5 212.4 ms
F1 sf
0.251 0.251 0 r
(//}}})s
F0 sf
0 g
(  )59.5 192.4 ms
F1 sf
0.251 0.251 0 r
(// count contacts between all molecules pairs //{{{)s
F0 sf
0 g
(  )59.5 182.4 ms
F1 sf
0.251 0.251 0 r
(// go over all pairs of molecules)s
F0 sf
0 g
(  )59.5 172.4 ms
0 0.125 0.251 r
(for)s
0 g
( \()s
0 0.251 0 r
(int)s
0 g
( i = )s
0 0.251 0 r
(1)s
0 g
(; i < \(*Counts\).Molecules; i++\) { )s
F1 sf
0.251 0.251 0 r
(// first molecule)s
F0 sf
0 g
(    )59.5 162.4 ms
0 0.125 0.251 r
(for)s
0 g
( \()s
0 0.251 0 r
(int)s
0 g
( j = )s
0 0.251 0 r
(0)s
0 g
(; j < i; j++\) { )s
F1 sf
0.251 0.251 0 r
(// second molecule)s
F0 sf
0 g
(      )59.5 142.4 ms
F1 sf
0.251 0.251 0 r
(// go over all beads in first molecule)s
F0 sf
0 g
(      )59.5 132.4 ms
0 0.125 0.251 r
(for)s
0 g
( \()s
0 0.251 0 r
(int)s
0 g
( k = )s
0 0.251 0 r
(0)s
0 g
(; k < MoleculeType[Molecule[i].Type].nBeads; k++\) {)s
(        )59.5 122.4 ms
0 0.251 0 r
(int)s
0 g
( id1 = Molecule[i].Bead[k];)s
(        )59.5 102.4 ms
F1 sf
0.251 0.251 0 r
(// go over all beads in second molecule if the bead type of id1 is in use)s
F0 sf
0 g
(        )59.5 92.4 ms
0 0.125 0.251 r
(for)s
0 g
( \()s
0 0.251 0 r
(int)s
0 g
( l = )s
0 0.251 0 r
(0)s
0 g
(; BeadType[\(*Bead\)[id1].Type].Use && l < MoleculeType[Molecule)s
([j].Type].nBeads; l++\) {)59.5 82.4 ms
(          )59.5 72.4 ms
0 0.251 0 r
(int)s
0 g
( id2 = Molecule[j].Bead[l];)s
(          )59.5 52.4 ms
F1 sf
0.251 0.251 0 r
(// should bead of this type be used to calculate aggregates?)s
re sp
%%PageTrailer
%%Page: 2 2
%%BeginPageSetup
sv
0 g
F0 sf
%%EndPageSetup
F1 sf
(Aggregates.c                                                                  Page 2)59.5 792.4 ms
F0 sf
(          )59.5 772.4 ms
0 0.125 0.251 r
(if)s
0 g
( \(BeadType[\(*Bead\)[id2].Type].Use\) {)s
(            )59.5 752.4 ms
F1 sf
0.251 0.251 0 r
(// calculate distance between k-th bead in molecule i and l-th bead in m)s
(olecule j)59.5 742.4 ms
F0 sf
0 g
(            Vector rij = DistanceBetweenBeads\(id1, id2, *Bead, BoxLength\);)59.5 732.4 ms
(            )59.5 712.4 ms
F1 sf
0.251 0.251 0 r
(// are 'id1' and 'id2' close enough?)s
F0 sf
0 g
(            )59.5 702.4 ms
0 0.125 0.251 r
(if)s
0 g
( \(\(SQR\(rij.x\) + SQR\(rij.y\) + SQR\(rij.z\)\) <= sqdist\))s
(              contact[i][j]++;)59.5 692.4 ms
(          })59.5 682.4 ms
(        })59.5 672.4 ms
(      })59.5 662.4 ms
(    })59.5 652.4 ms
(  } )59.5 642.4 ms
F1 sf
0.251 0.251 0 r
(//}}})s
F0 sf
0 g
(  )59.5 622.4 ms
F1 sf
0.251 0.251 0 r
(// evaluate the contacts //{{{)s
F0 sf
0 g
(  )59.5 612.4 ms
F1 sf
0.251 0.251 0 r
(// first molecule)s
F0 sf
0 g
(  )59.5 602.4 ms
0 0.125 0.251 r
(for)s
0 g
( \()s
0 0.251 0 r
(int)s
0 g
( i = )s
0 0.251 0 r
(1)s
0 g
(; i < \(*Counts\).Molecules; i++\) {)s
(    )59.5 582.4 ms
F1 sf
0.251 0.251 0 r
(// second molecule)s
F0 sf
0 g
(    )59.5 572.4 ms
0 0.125 0.251 r
(for)s
0 g
( \()s
0 0.251 0 r
(int)s
0 g
( j = )s
0 0.251 0 r
(0)s
0 g
(; j < i; j++\) {)s
(      )59.5 552.4 ms
F1 sf
0.251 0.251 0 r
(// find out if Molecule[i] is in any aggregate //{{{)s
F0 sf
0 g
(      )59.5 542.4 ms
0 0.251 0 r
(int)s
0 g
( testi = -)s
0 0.251 0 r
(1)s
0 g
(;)s
(      )59.5 532.4 ms
0 0.125 0.251 r
(for)s
0 g
( \()s
0 0.251 0 r
(int)s
0 g
( k = )s
0 0.251 0 r
(0)s
0 g
(; k < \(*Counts\).Aggregates; k++\) {)s
(        )59.5 522.4 ms
0 0.125 0.251 r
(for)s
0 g
( \()s
0 0.251 0 r
(int)s
0 g
( l = )s
0 0.251 0 r
(0)s
0 g
(; l < \(*Aggregate\)[k].nMolecules; l++\) {)s
(          )59.5 512.4 ms
0 0.125 0.251 r
(if)s
0 g
( \(i == \(*Aggregate\)[k].Molecule[l]\) {)s
(            testi = k;)59.5 502.4 ms
(            )59.5 492.4 ms
0 0.125 0.251 r
(break)s
0 g
(;)s
(          })59.5 482.4 ms
(        })59.5 472.4 ms
(        )59.5 452.4 ms
F1 sf
0.251 0.251 0 r
(// if 'i' is in aggregate, no need to go through the rest of aggregates)s
F0 sf
0 g
(        )59.5 442.4 ms
0 0.125 0.251 r
(if)s
0 g
( \(testi != -)s
0 0.251 0 r
(1)s
0 g
(\))s
(          )59.5 432.4 ms
0 0.125 0.251 r
(break)s
0 g
(;)s
(      } )59.5 422.4 ms
F1 sf
0.251 0.251 0 r
(//}}})s
F0 sf
0 g
(      )59.5 402.4 ms
F1 sf
0.251 0.251 0 r
(// find out if Molecule[j] is in any aggregate //{{{)s
F0 sf
0 g
(      )59.5 392.4 ms
0 0.251 0 r
(int)s
0 g
( testj = -)s
0 0.251 0 r
(1)s
0 g
(;)s
(      )59.5 382.4 ms
0 0.125 0.251 r
(for)s
0 g
( \()s
0 0.251 0 r
(int)s
0 g
( k = )s
0 0.251 0 r
(0)s
0 g
(; k < \(*Counts\).Aggregates; k++\) {)s
(        )59.5 372.4 ms
0 0.125 0.251 r
(for)s
0 g
( \()s
0 0.251 0 r
(int)s
0 g
( l = )s
0 0.251 0 r
(0)s
0 g
(; l < \(*Aggregate\)[k].nMolecules; l++\) {)s
(          )59.5 362.4 ms
0 0.125 0.251 r
(if)s
0 g
( \(j == \(*Aggregate\)[k].Molecule[l]\) {)s
(            testj = k;)59.5 352.4 ms
(            )59.5 342.4 ms
0 0.125 0.251 r
(break)s
0 g
(;)s
(          })59.5 332.4 ms
(        })59.5 322.4 ms
(        )59.5 302.4 ms
F1 sf
0.251 0.251 0 r
(// if 'j' is in aggregate, no need to go through the rest of aggregates)s
F0 sf
0 g
(        )59.5 292.4 ms
0 0.125 0.251 r
(if)s
0 g
( \(testj != -)s
0 0.251 0 r
(1)s
0 g
(\))s
(          )59.5 282.4 ms
0 0.125 0.251 r
(break)s
0 g
(;)s
(      } )59.5 272.4 ms
F1 sf
0.251 0.251 0 r
(//}}})s
F0 sf
0 g
( )59.5 252.4 ms
F1 sf
0.251 0.251 0 r
(//   printf\("%d\\n", \(*Counts\).Aggregates\);)s
F0 sf
0 g
( )59.5 242.4 ms
F1 sf
0.251 0.251 0 r
(//         printf\("testi=%d testj=%d\\n", testi, testj\);)s
F0 sf
0 g
(      )59.5 222.4 ms
F1 sf
0.251 0.251 0 r
(// molecules 'i' and 'j' are in contact //{{{)s
F0 sf
0 g
(      )59.5 212.4 ms
0 0.125 0.251 r
(if)s
0 g
( \(contact[i][j] >= contacts\) {)s
(        )59.5 202.4 ms
F1 sf
0.251 0.251 0 r
(// create new aggregate if 'j' isn'it in any //{{{)s
F0 sf
0 g
(        )59.5 192.4 ms
0 0.125 0.251 r
(if)s
0 g
( \(testj == -)s
0 0.251 0 r
(1)s
0 g
(\) {)s
(          testj = \(*Counts\).Aggregates;)59.5 182.4 ms
(          \(*Aggregate\)[testj].nMolecules = )59.5 162.4 ms
0 0.251 0 r
(1)s
0 g
(;)s
(          \(*Aggregate\)[testj].Molecule[)59.5 152.4 ms
0 0.251 0 r
(0)s
0 g
(] = j;)s
(          \(*Counts\).Aggregates++;)59.5 132.4 ms
(        } )59.5 122.4 ms
F1 sf
0.251 0.251 0 r
(//}}})s
F0 sf
0 g
(        )59.5 102.4 ms
F1 sf
0.251 0.251 0 r
(// add 'i' to aggregate if 'i' isn't in any //{{{)s
F0 sf
0 g
(        )59.5 92.4 ms
0 0.125 0.251 r
(if)s
0 g
( \(testi == -)s
0 0.251 0 r
(1)s
0 g
(\) {)s
(          \(*Aggregate\)[testj].Molecule[\(*Aggregate\)[testj].nMolecules] = i;)59.5 82.4 ms
(          \(*Aggregate\)[testj].nMolecules++;)59.5 62.4 ms
(        } )59.5 52.4 ms
F1 sf
0.251 0.251 0 r
(//}}})s
re sp
%%PageTrailer
%%Page: 3 3
%%BeginPageSetup
sv
0 g
F0 sf
%%EndPageSetup
F1 sf
(Aggregates.c                                                                  Page 3)59.5 792.4 ms
F0 sf
(        )59.5 762.4 ms
F1 sf
0.251 0.251 0 r
(// each residue in different aggregate => unite aggregates)s
F0 sf
0 g
(        )59.5 752.4 ms
0 0.125 0.251 r
(if)s
0 g
( \(testi != -)s
0 0.251 0 r
(1)s
0 g
( && testj != -)s
0 0.251 0 r
(1)s
0 g
( && testi != testj\) {)s
(          )59.5 732.4 ms
F1 sf
0.251 0.251 0 r
(// add molecules from aggregate 'testi' to 'testj' //{{{)s
F0 sf
0 g
(          )59.5 722.4 ms
0 0.251 0 r
(int)s
0 g
( mols = \(*Aggregate\)[testj].nMolecules;)s
(          \(*Aggregate\)[testj].nMolecules += \(*Aggregate\)[testi].nMolecules;)59.5 702.4 ms
(          )59.5 692.4 ms
0 0.251 0 r
(int)s
0 g
( id1 = )s
0 0.251 0 r
(0)s
0 g
(;)s
(          )59.5 682.4 ms
F1 sf
0.251 0.251 0 r
(// copy molecule ids from Aggregate[testi-1] to Aggregate[testj-1] */)s
F0 sf
0 g
(          )59.5 672.4 ms
0 0.125 0.251 r
(for)s
0 g
( \()s
0 0.251 0 r
(int)s
0 g
( k = mols; k < \(*Aggregate\)[testj].nMolecules; k++\) {)s
(            \(*Aggregate\)[testj].Molecule[k] = \(*Aggregate\)[testi].Molecule[id1];)59.5 662.4 ms
(            id1++;)59.5 652.4 ms
(          } )59.5 642.4 ms
F1 sf
0.251 0.251 0 r
(//}}})s
F0 sf
0 g
(          )59.5 622.4 ms
F1 sf
0.251 0.251 0 r
(// move aggregates with id greater then testi to id-1 //{{{)s
F0 sf
0 g
(          )59.5 612.4 ms
0 0.125 0.251 r
(for)s
0 g
( \()s
0 0.251 0 r
(int)s
0 g
( k = \(testi+)s
0 0.251 0 r
(1)s
0 g
(\); k < \(*Counts\).Aggregates; k++\) {)s
(            \(*Aggregate\)[k-)59.5 592.4 ms
0 0.251 0 r
(1)s
0 g
(].nMolecules = \(*Aggregate\)[k].nMolecules;)s
(            )59.5 572.4 ms
F1 sf
0.251 0.251 0 r
(// move every molecule from aggregate 'k' to aggregate 'k-1')s
F0 sf
0 g
(            )59.5 562.4 ms
0 0.125 0.251 r
(for)s
0 g
( \()s
0 0.251 0 r
(int)s
0 g
( l = )s
0 0.251 0 r
(0)s
0 g
(; l < \(*Aggregate\)[k].nMolecules; l++\) {)s
(              \(*Aggregate\)[k-)59.5 552.4 ms
0 0.251 0 r
(1)s
0 g
(].Molecule[l] = \(*Aggregate\)[k].Molecule[l];)s
(            })59.5 542.4 ms
(          } )59.5 532.4 ms
F1 sf
0.251 0.251 0 r
(//}}})s
F0 sf
0 g
(          )59.5 512.4 ms
F1 sf
0.251 0.251 0 r
(// reduce number of aggregates \(two aggregates were merged\))s
F0 sf
0 g
(          \(*Counts\).Aggregates--;)59.5 502.4 ms
(        } )59.5 492.4 ms
F1 sf
0.251 0.251 0 r
(//}}})s
F0 sf
0 g
(      )59.5 482.4 ms
F1 sf
0.251 0.251 0 r
(// or 'i' and 'j' aren't in contact and 'j' isn't in any aggregate =>  new agg)s
(regate for 'j' */ //{{{)59.5 472.4 ms
F0 sf
0 g
(      } )59.5 462.4 ms
0 0.125 0.251 r
(else)s
0 g
( )s
0 0.125 0.251 r
(if)s
0 g
( \(testj == -)s
0 0.251 0 r
(1)s
0 g
(\) {)s
(        \(*Aggregate\)[\(*Counts\).Aggregates].nMolecules = )59.5 452.4 ms
0 0.251 0 r
(1)s
0 g
(;)s
(        \(*Aggregate\)[\(*Counts\).Aggregates].Molecule[)59.5 442.4 ms
0 0.251 0 r
(0)s
0 g
(] = j;)s
(        \(*Counts\).Aggregates++;)59.5 422.4 ms
(      } )59.5 412.4 ms
F1 sf
0.251 0.251 0 r
(//}}})s
F0 sf
0 g
(    })59.5 402.4 ms
(  } )59.5 392.4 ms
F1 sf
0.251 0.251 0 r
(//}}})s
F0 sf
0 g
(  )59.5 372.4 ms
F1 sf
0.251 0.251 0 r
(// if residue with highest id is in no aggregate, create it //{{{)s
F0 sf
0 g
(  )59.5 362.4 ms
F1 sf
0.251 0.251 0 r
(// check if highest id residue is in aggregate //{{{)s
F0 sf
0 g
(  )59.5 352.4 ms
0 0.251 0 r
(bool)s
0 g
( test = )s
0 0.251 0 r
(false)s
0 g
(;)s
(  )59.5 342.4 ms
0 0.125 0.251 r
(for)s
0 g
( \()s
0 0.251 0 r
(int)s
0 g
( i = )s
0 0.251 0 r
(0)s
0 g
(; i < \(*Counts\).Aggregates; i++\) {)s
(    )59.5 332.4 ms
0 0.125 0.251 r
(for)s
0 g
( \()s
0 0.251 0 r
(int)s
0 g
( j = )s
0 0.251 0 r
(1)s
0 g
(; j < \(*Aggregate\)[i].nMolecules; j++\) {)s
(      )59.5 322.4 ms
0 0.125 0.251 r
(if)s
0 g
( \(\(*Aggregate\)[i].Molecule[j] == \(\(*Counts\).Molecules-)s
0 0.251 0 r
(1)s
0 g
(\)\) {)s
(        test = )59.5 312.4 ms
0 0.251 0 r
(1)s
0 g
(;)s
(      })59.5 302.4 ms
(    })59.5 292.4 ms
(  } )59.5 282.4 ms
F1 sf
0.251 0.251 0 r
(//}}})s
F0 sf
0 g
(  )59.5 262.4 ms
F1 sf
0.251 0.251 0 r
(/* highest id residue not in any aggregate => create separate one */)s
F0 sf
0 g
( )s
F1 sf
0.251 0.251 0 r
(//{{{)s
F0 sf
0 g
(  )59.5 252.4 ms
0 0.125 0.251 r
(if)s
0 g
( \(!test\) {)s
(    \(*Aggregate\)[\(*Counts\).Aggregates].nMolecules = )59.5 242.4 ms
0 0.251 0 r
(1)s
0 g
(;)s
(    \(*Aggregate\)[\(*Counts\).Aggregates].Molecule[)59.5 232.4 ms
0 0.251 0 r
(0)s
0 g
(] = \(*Counts\).Molecules - )s
0 0.251 0 r
(1)s
0 g
(;)s
(    \(*Counts\).Aggregates++;)59.5 212.4 ms
(  } )59.5 202.4 ms
F1 sf
0.251 0.251 0 r
(//}}})s
F0 sf
0 g
(  )59.5 192.4 ms
F1 sf
0.251 0.251 0 r
(//}}})s
F0 sf
0 g
(  )59.5 172.4 ms
F1 sf
0.251 0.251 0 r
(// bubble sort molecules in aggregates according to ascending ids //{{{)s
F0 sf
0 g
(  )59.5 162.4 ms
0 0.125 0.251 r
(for)s
0 g
( \()s
0 0.251 0 r
(int)s
0 g
( i = )s
0 0.251 0 r
(0)s
0 g
(; i < \(*Counts\).Aggregates; i++\) {)s
(    )59.5 142.4 ms
0 0.125 0.251 r
(for)s
0 g
( \()s
0 0.251 0 r
(int)s
0 g
( j = )s
0 0.251 0 r
(0)s
0 g
( ; j < \(\(*Aggregate\)[i].nMolecules-)s
0 0.251 0 r
(1)s
0 g
(\); j++\) {)s
(      )59.5 132.4 ms
0 0.251 0 r
(bool)s
0 g
( done = )s
0 0.251 0 r
(true)s
0 g
(;)s
(      )59.5 112.4 ms
0 0.125 0.251 r
(for)s
0 g
( \()s
0 0.251 0 r
(int)s
0 g
( k = )s
0 0.251 0 r
(0)s
0 g
( ; k < \(\(*Aggregate\)[i].nMolecules-j-)s
0 0.251 0 r
(1)s
0 g
(\); k++\) {)s
(        )59.5 92.4 ms
0 0.125 0.251 r
(if)s
0 g
( \(\(*Aggregate\)[i].Molecule[k] > \(*Aggregate\)[i].Molecule[k+)s
0 0.251 0 r
(1)s
0 g
(]\) {)s
(          )59.5 72.4 ms
0 0.251 0 r
(int)s
0 g
( swap = \(*Aggregate\)[i].Molecule[k];)s
(          \(*Aggregate\)[i].Molecule[k] = \(*Aggregate\)[i].Molecule[k+)59.5 62.4 ms
0 0.251 0 r
(1)s
0 g
(];)s
(          \(*Aggregate\)[i].Molecule[k+)59.5 52.4 ms
0 0.251 0 r
(1)s
0 g
(] = swap;)s
re sp
%%PageTrailer
%%Page: 4 4
%%BeginPageSetup
sv
0 g
F0 sf
%%EndPageSetup
F1 sf
(Aggregates.c                                                                  Page 4)59.5 792.4 ms
F0 sf
(          done = )59.5 762.4 ms
0 0.251 0 r
(false)s
0 g
(;)s
(        })59.5 752.4 ms
(      })59.5 742.4 ms
(      )59.5 732.4 ms
0 0.125 0.251 r
(if)s
0 g
( \(done\))s
(        )59.5 722.4 ms
0 0.125 0.251 r
(break)s
0 g
(;)s
(    })59.5 712.4 ms
(  } )59.5 702.4 ms
F1 sf
0.251 0.251 0 r
(//}}})s
F0 sf
0 g
(  )59.5 682.4 ms
F1 sf
0.251 0.251 0 r
(// bubble sort aggregates according to ascending ids of first molecules //{{{)s
F0 sf
0 g
(  )59.5 672.4 ms
0 0.125 0.251 r
(for)s
0 g
( \()s
0 0.251 0 r
(int)s
0 g
( i = )s
0 0.251 0 r
(0)s
0 g
(; i < \(\(*Counts\).Aggregates-)s
0 0.251 0 r
(1)s
0 g
(\); i++\) {)s
(    )59.5 662.4 ms
0 0.251 0 r
(bool)s
0 g
( done = )s
0 0.251 0 r
(true)s
0 g
(;)s
(    )59.5 642.4 ms
0 0.125 0.251 r
(for)s
0 g
( \()s
0 0.251 0 r
(int)s
0 g
( j = )s
0 0.251 0 r
(0)s
0 g
(; j < \(\(*Counts\).Aggregates-i-)s
0 0.251 0 r
(1)s
0 g
(\); j++\) {)s
(      )59.5 622.4 ms
0 0.125 0.251 r
(if)s
0 g
( \(\(*Aggregate\)[j].Molecule[)s
0 0.251 0 r
(0)s
0 g
(] > \(*Aggregate\)[j+)s
0 0.251 0 r
(1)s
0 g
(].Molecule[)s
0 0.251 0 r
(0)s
0 g
(]\) {)s
(        )59.5 612.4 ms
F1 sf
0.251 0.251 0 r
(// swtich numbers of molecules)s
F0 sf
0 g
(        )59.5 602.4 ms
0 0.251 0 r
(int)s
0 g
( swap = \(*Aggregate\)[j].nMolecules;)s
(        \(*Aggregate\)[j].nMolecules = \(*Aggregate\)[j+)59.5 592.4 ms
0 0.251 0 r
(1)s
0 g
(].nMolecules;)s
(        \(*Aggregate\)[j+)59.5 582.4 ms
0 0.251 0 r
(1)s
0 g
(].nMolecules = swap;)s
(        )59.5 562.4 ms
F1 sf
0.251 0.251 0 r
(// switch the whole Aggregate[].Molecule array \(no idea which aggregate cont)s
(ains more molecules\))59.5 552.4 ms
F0 sf
0 g
(        )59.5 542.4 ms
0 0.125 0.251 r
(for)s
0 g
( \()s
0 0.251 0 r
(int)s
0 g
( k = )s
0 0.251 0 r
(0)s
0 g
(; k < \(*Counts\).Molecules; k++\) {)s
(          swap = \(*Aggregate\)[j].Molecule[k];)59.5 532.4 ms
(          \(*Aggregate\)[j].Molecule[k] = \(*Aggregate\)[j+)59.5 522.4 ms
0 0.251 0 r
(1)s
0 g
(].Molecule[k];)s
(          \(*Aggregate\)[j+)59.5 512.4 ms
0 0.251 0 r
(1)s
0 g
(].Molecule[k] = swap;)s
(        })59.5 502.4 ms
(        done = )59.5 482.4 ms
0 0.251 0 r
(false)s
0 g
(;)s
(      })59.5 472.4 ms
(    })59.5 462.4 ms
(    )59.5 452.4 ms
0 0.125 0.251 r
(if)s
0 g
( \(done\))s
(      )59.5 442.4 ms
0 0.125 0.251 r
(break)s
0 g
(;)s
(  } )59.5 432.4 ms
F1 sf
0.251 0.251 0 r
(//}}})s
F0 sf
0 g
(  FillAggregateBeads\(Aggregate, *Counts, MoleculeType, Molecule\);)59.5 412.4 ms
(  )59.5 392.4 ms
F1 sf
0.251 0.251 0 r
(// calculate the number of monomeric beads in aggregate //{{{)s
F0 sf
0 g
(  )59.5 382.4 ms
F1 sf
0.251 0.251 0 r
(// go through all unbonded beads)s
F0 sf
0 g
(  )59.5 372.4 ms
0 0.125 0.251 r
(for)s
0 g
( \()s
0 0.251 0 r
(int)s
0 g
( i = )s
0 0.251 0 r
(0)s
0 g
(; i < \(\(*Counts\).Unbonded+\(*Counts\).Bonded\); i++\) {)s
(    )59.5 362.4 ms
0 0.125 0.251 r
(if)s
0 g
( \(\(*Bead\)[i].Molecule == -)s
0 0.251 0 r
(1)s
0 g
(\) { )s
F1 sf
0.251 0.251 0 r
(// -1 means 'in no molecule')s
F0 sf
0 g
(      )59.5 342.4 ms
F1 sf
0.251 0.251 0 r
(// go through all aggregates)s
F0 sf
0 g
(      )59.5 332.4 ms
0 0.125 0.251 r
(for)s
0 g
( \()s
0 0.251 0 r
(int)s
0 g
( j = )s
0 0.251 0 r
(0)s
0 g
(; j < \(*Counts\).Aggregates; j++\) {)s
(        )59.5 322.4 ms
0 0.251 0 r
(bool)s
0 g
( in_agg = )s
0 0.251 0 r
(false)s
0 g
(;)s
(        )59.5 302.4 ms
F1 sf
0.251 0.251 0 r
(// go through all molecules in aggregate 'j')s
F0 sf
0 g
(        )59.5 292.4 ms
0 0.125 0.251 r
(for)s
0 g
( \()s
0 0.251 0 r
(int)s
0 g
( k = )s
0 0.251 0 r
(0)s
0 g
(; k < \(*Aggregate\)[j].nMolecules; k++\) {)s
(          )59.5 282.4 ms
0 0.251 0 r
(int)s
0 g
( id = \(*Aggregate\)[j].Molecule[k];)s
(          )59.5 262.4 ms
F1 sf
0.251 0.251 0 r
(// go through all beads in molecule 'id')s
F0 sf
0 g
(          )59.5 252.4 ms
0 0.125 0.251 r
(for)s
0 g
( \()s
0 0.251 0 r
(int)s
0 g
( l = )s
0 0.251 0 r
(0)s
0 g
(; l < MoleculeType[Molecule[id].Type].nBeads; l++\) {)s
(            )59.5 232.4 ms
F1 sf
0.251 0.251 0 r
(// calculate distance between monomeric bead 'i' and bead 'Molecule[id].)s
(Bead[l]')59.5 222.4 ms
F0 sf
0 g
(            Vector dist = DistanceBetweenBeads\(i, Molecule[id].Bead[l], *Bead, BoxLe)59.5 212.4 ms
(ngth\);)59.5 202.4 ms
(            )59.5 182.4 ms
0 0.125 0.251 r
(if)s
0 g
( \(\(SQR\(dist.x\)+SQR\(dist.y\)+SQR\(dist.z\)\) < sqdist\) {)s
(              \(*Aggregate\)[j].Monomer[\(*Aggregate\)[j].nMonomers] = \(*Bead\)[i].Index;)59.5 172.4 ms
(              \(*Aggregate\)[j].nMonomers++;)59.5 162.4 ms
(              in_agg = )59.5 142.4 ms
0 0.251 0 r
(true)s
0 g
(;)s
(              )59.5 122.4 ms
0 0.125 0.251 r
(break)s
0 g
(;)s
(            })59.5 112.4 ms
(          })59.5 102.4 ms
(          )59.5 82.4 ms
0 0.125 0.251 r
(if)s
0 g
( \(in_agg\))s
(            )59.5 72.4 ms
0 0.125 0.251 r
(break)s
0 g
(;)s
(        })59.5 62.4 ms
(      })59.5 52.4 ms
re sp
%%PageTrailer
%%Page: 5 5
%%BeginPageSetup
sv
0 g
F0 sf
%%EndPageSetup
F1 sf
(Aggregates.c                                                                  Page 5)59.5 792.4 ms
F0 sf
(    })59.5 772.4 ms
(  } )59.5 762.4 ms
F1 sf
0.251 0.251 0 r
(//}}})s
F0 sf
0 g
(  )59.5 742.4 ms
F1 sf
0.251 0.251 0 r
(// free memory //{{{)s
F0 sf
0 g
(  )59.5 732.4 ms
0 0.125 0.251 r
(for)s
0 g
( \()s
0 0.251 0 r
(int)s
0 g
( i = )s
0 0.251 0 r
(0)s
0 g
(; i < \(*Counts\).Molecules; i++\))s
(    free\(contact[i]\);)59.5 722.4 ms
(  free\(contact\);)59.5 712.4 ms
(  free\(moved\); )59.5 702.4 ms
F1 sf
0.251 0.251 0 r
(//}}})s
F0 sf
0 g
(} )59.5 692.4 ms
F1 sf
0.251 0.251 0 r
(//}}})s
F0 sf
0 0.251 0 r
(void)59.5 672.4 ms
0 g
( RemovePBCAggregates\(Aggregate *Aggregate, Counts Counts, )s
F1 sf
0.251 0.251 0 r
(//{{{)s
F0 sf
0 g
(                         Vector BoxLength, BeadType *BeadType, Bead **Bead,)59.5 662.4 ms
(                         MoleculeType *MoleculeType, Molecule *Molecule\) {)59.5 652.4 ms
(  )59.5 632.4 ms
0 0.251 0 r
(bool)s
0 g
( *moved = malloc\(Counts.Molecules*)s
0 0.125 0.251 r
(sizeof)s
0 g
(\()s
0 0.251 0 r
(bool)s
0 g
(\)\);)s
(  )59.5 622.4 ms
0 0.251 0 r
(double)s
0 g
( distance = )s
0 0.251 0 r
(1)s
0 g
(;)s
(  )59.5 602.4 ms
F1 sf
0.251 0.251 0 r
(// go through all aggregates larger than unimers)s
F0 sf
0 g
(  )59.5 592.4 ms
0 0.125 0.251 r
(for)s
0 g
( \()s
0 0.251 0 r
(int)s
0 g
( i = )s
0 0.251 0 r
(0)s
0 g
(; i < Counts.Aggregates; i++\) {)s
(    )59.5 572.4 ms
F1 sf
0.251 0.251 0 r
(// negate moved array, while first bead is not to move //{{{)s
F0 sf
0 g
(    )59.5 562.4 ms
0 0.125 0.251 r
(for)s
0 g
( \()s
0 0.251 0 r
(int)s
0 g
( j = )s
0 0.251 0 r
(1)s
0 g
(; j < Counts.Molecules; j++\) {)s
(      moved[j] = )59.5 552.4 ms
0 0.251 0 r
(false)s
0 g
(;)s
(    })59.5 542.4 ms
(    moved[)59.5 532.4 ms
0 0.251 0 r
(0)s
0 g
(] = )s
0 0.251 0 r
(true)s
0 g
(; )s
F1 sf
0.251 0.251 0 r
(//}}})s
F0 sf
0 g
(    )59.5 512.4 ms
0 0.251 0 r
(bool)s
0 g
( done = )s
0 0.251 0 r
(false)s
0 g
(;)s
(    )59.5 502.4 ms
0 0.125 0.251 r
(while)s
0 g
( \(!done\) {)s
(      )59.5 482.4 ms
F1 sf
0.251 0.251 0 r
(// go through all molecule pairs)s
F0 sf
0 g
(      )59.5 472.4 ms
0 0.125 0.251 r
(for)s
0 g
( \()s
0 0.251 0 r
(int)s
0 g
( j = )s
0 0.251 0 r
(0)s
0 g
(; j < Aggregate[i].nMolecules; j++\) {)s
(        )59.5 462.4 ms
0 0.125 0.251 r
(for)s
0 g
( \()s
0 0.251 0 r
(int)s
0 g
( k = )s
0 0.251 0 r
(0)s
0 g
(; moved[j] && k < Aggregate[i].nMolecules; k++\) {)s
(          )59.5 442.4 ms
F1 sf
0.251 0.251 0 r
(// use only moved molecule 'mol_j' and unmoved molecule 'mol_k')s
F0 sf
0 g
(          )59.5 432.4 ms
0 0.125 0.251 r
(if)s
0 g
( \(moved[j] && !moved[k]\) { )s
F1 sf
0.251 0.251 0 r
(// automatically follows that j!=k)s
F0 sf
0 g
(            )59.5 422.4 ms
0 0.251 0 r
(int)s
0 g
( mol1 = Aggregate[i].Molecule[j];)s
(            )59.5 412.4 ms
0 0.251 0 r
(int)s
0 g
( mol2 = Aggregate[i].Molecule[k];)s
(            )59.5 392.4 ms
F1 sf
0.251 0.251 0 r
(// go through all bead pairs in the two molecules)s
F0 sf
0 g
(            )59.5 382.4 ms
0 0.125 0.251 r
(for)s
0 g
( \()s
0 0.251 0 r
(int)s
0 g
( l = )s
0 0.251 0 r
(0)s
0 g
(; l < MoleculeType[Molecule[mol1].Type].nBeads; l++\) {)s
(              )59.5 372.4 ms
0 0.125 0.251 r
(for)s
0 g
( \()s
0 0.251 0 r
(int)s
0 g
( m = )s
0 0.251 0 r
(0)s
0 g
(; m < MoleculeType[Molecule[mol2].Type].nBeads; m++\) {)s
(                )59.5 362.4 ms
0 0.251 0 r
(int)s
0 g
( bead1 = Molecule[mol1].Bead[l];)s
(                )59.5 352.4 ms
0 0.251 0 r
(int)s
0 g
( bead2 = Molecule[mol2].Bead[m];)s
(                )59.5 342.4 ms
0 0.125 0.251 r
(if)s
0 g
( \(BeadType[\(*Bead\)[bead1].Type].Use && BeadType[\(*Bead\)[bead2].Typ)s
(e].Use\) {)59.5 332.4 ms
(                  )59.5 312.4 ms
F1 sf
0.251 0.251 0 r
(// calculate distance between 'bead1' and 'bead2')s
F0 sf
0 g
(                  Vector dist = DistanceBetweenBeads\(bead1, bead2, *Bead, BoxLength\))59.5 302.4 ms
(;)59.5 292.4 ms
(                  )59.5 282.4 ms
0 0.251 0 r
(double)s
0 g
( sqdist = SQR\(dist.x\) + SQR\(dist.y\) + SQR\(dist.z\);)s
(                  )59.5 262.4 ms
F1 sf
0.251 0.251 0 r
(// move 'mol2' if 'bead1' and 'bead2' are in contact)s
F0 sf
0 g
(                  )59.5 252.4 ms
0 0.125 0.251 r
(if)s
0 g
( \(sqdist < distance\) {)s
(                    )59.5 232.4 ms
F1 sf
0.251 0.251 0 r
(// distance vector between 'bead1' and 'bead2')s
F0 sf
0 g
(                    Vector dist;)59.5 222.4 ms
(                    dist.x = \(*Bead\)[bead1].Position.x - \(*Bead\)[bead2].Position.x;)59.5 212.4 ms
(                    dist.y = \(*Bead\)[bead1].Position.y - \(*Bead\)[bead2].Position.y;)59.5 202.4 ms
(                    dist.z = \(*Bead\)[bead1].Position.z - \(*Bead\)[bead2].Position.z;)59.5 192.4 ms
(                    )59.5 172.4 ms
F1 sf
0.251 0.251 0 r
(// if 'bead1' and 'bead2' are too far in x-direction, move 'mol2)s
(' in x-direction //{{{)59.5 162.4 ms
F0 sf
0 g
(                    )59.5 152.4 ms
0 0.125 0.251 r
(if)s
0 g
( \(dist.x > \(BoxLength.x/)s
0 0.251 0 r
(2)s
0 g
(\)\) {)s
(                      )59.5 142.4 ms
0 0.125 0.251 r
(for)s
0 g
( \()s
0 0.251 0 r
(int)s
0 g
( n = )s
0 0.251 0 r
(0)s
0 g
(; n < MoleculeType[Molecule[mol2].Type].nBeads; )s
(n++\) {)59.5 132.4 ms
(                        \(*Bead\)[Molecule[mol2].Bead[n]].Position.x += BoxLength.x;)59.5 122.4 ms
(                      })59.5 112.4 ms
(                    } )59.5 102.4 ms
0 0.125 0.251 r
(else)s
0 g
( )s
0 0.125 0.251 r
(if)s
0 g
( \(dist.x <= -\(BoxLength.x/)s
0 0.251 0 r
(2)s
0 g
(\)\) {)s
(                      )59.5 92.4 ms
0 0.125 0.251 r
(for)s
0 g
( \()s
0 0.251 0 r
(int)s
0 g
( n = )s
0 0.251 0 r
(0)s
0 g
(; n < MoleculeType[Molecule[mol2].Type].nBeads; )s
(n++\) {)59.5 82.4 ms
(                        \(*Bead\)[Molecule[mol2].Bead[n]].Position.x -= BoxLength.x;)59.5 72.4 ms
(                      })59.5 62.4 ms
(                    } )59.5 52.4 ms
F1 sf
0.251 0.251 0 r
(//}}})s
re sp
%%PageTrailer
%%Page: 6 6
%%BeginPageSetup
sv
0 g
F0 sf
%%EndPageSetup
F1 sf
(Aggregates.c                                                                  Page 6)59.5 792.4 ms
F0 sf
(                    )59.5 762.4 ms
F1 sf
0.251 0.251 0 r
(// if 'bead1' and 'bead2' are too far in y-direction, move 'mol2)s
(' in y-direction //{{{)59.5 752.4 ms
F0 sf
0 g
(                    )59.5 742.4 ms
0 0.125 0.251 r
(if)s
0 g
( \(dist.y > \(BoxLength.y/)s
0 0.251 0 r
(2)s
0 g
(\)\) {)s
(                      )59.5 732.4 ms
0 0.125 0.251 r
(for)s
0 g
( \()s
0 0.251 0 r
(int)s
0 g
( n = )s
0 0.251 0 r
(0)s
0 g
(; n < MoleculeType[Molecule[mol2].Type].nBeads; )s
(n++\) {)59.5 722.4 ms
(                        \(*Bead\)[Molecule[mol2].Bead[n]].Position.y += BoxLength.y;)59.5 712.4 ms
(                      })59.5 702.4 ms
(                    } )59.5 692.4 ms
0 0.125 0.251 r
(else)s
0 g
( )s
0 0.125 0.251 r
(if)s
0 g
( \(dist.x <= -\(BoxLength.x/)s
0 0.251 0 r
(2)s
0 g
(\)\) {)s
(                      )59.5 682.4 ms
0 0.125 0.251 r
(for)s
0 g
( \()s
0 0.251 0 r
(int)s
0 g
( n = )s
0 0.251 0 r
(0)s
0 g
(; n < MoleculeType[Molecule[mol2].Type].nBeads; )s
(n++\) {)59.5 672.4 ms
(                        \(*Bead\)[Molecule[mol2].Bead[n]].Position.y -= BoxLength.y;)59.5 662.4 ms
(                      })59.5 652.4 ms
(                    } )59.5 642.4 ms
F1 sf
0.251 0.251 0 r
(//}}})s
F0 sf
0 g
(                    )59.5 622.4 ms
F1 sf
0.251 0.251 0 r
(// if 'bead1' and 'bead2' are too far in x-direction, move 'mol2)s
(' in x-direction //{{{)59.5 612.4 ms
F0 sf
0 g
(                    )59.5 602.4 ms
0 0.125 0.251 r
(if)s
0 g
( \(dist.z > \(BoxLength.z/)s
0 0.251 0 r
(2)s
0 g
(\)\) {)s
(                      )59.5 592.4 ms
0 0.125 0.251 r
(for)s
0 g
( \()s
0 0.251 0 r
(int)s
0 g
( n = )s
0 0.251 0 r
(0)s
0 g
(; n < MoleculeType[Molecule[mol2].Type].nBeads; )s
(n++\) {)59.5 582.4 ms
(                        \(*Bead\)[Molecule[mol2].Bead[n]].Position.z += BoxLength.z;)59.5 572.4 ms
(                      })59.5 562.4 ms
(                    } )59.5 552.4 ms
0 0.125 0.251 r
(else)s
0 g
( )s
0 0.125 0.251 r
(if)s
0 g
( \(dist.x <= -\(BoxLength.x/)s
0 0.251 0 r
(2)s
0 g
(\)\) {)s
(                      )59.5 542.4 ms
0 0.125 0.251 r
(for)s
0 g
( \()s
0 0.251 0 r
(int)s
0 g
( n = )s
0 0.251 0 r
(0)s
0 g
(; n < MoleculeType[Molecule[mol2].Type].nBeads; )s
(n++\) {)59.5 532.4 ms
(                        \(*Bead\)[Molecule[mol2].Bead[n]].Position.z -= BoxLength.z;)59.5 522.4 ms
(                      })59.5 512.4 ms
(                    } )59.5 502.4 ms
F1 sf
0.251 0.251 0 r
(//}}})s
F0 sf
0 g
(                    moved[k] = )59.5 482.4 ms
0 0.251 0 r
(true)s
0 g
(;)s
(                    )59.5 462.4 ms
F1 sf
0.251 0.251 0 r
(// skip remainder of 'mol2' \(or 'k'\))s
F0 sf
0 g
(                    )59.5 452.4 ms
0 0.125 0.251 r
(break)s
0 g
(;)s
(                  })59.5 442.4 ms
(                })59.5 432.4 ms
(              })59.5 422.4 ms
(              )59.5 412.4 ms
F1 sf
0.251 0.251 0 r
(// if molekule 'k' \(or 'mol2'\) has been moved, skip also remainder of )s
('mol1')59.5 402.4 ms
F0 sf
0 g
(              )59.5 392.4 ms
0 0.125 0.251 r
(if)s
0 g
( \(moved[k]\) {)s
(                )59.5 382.4 ms
0 0.125 0.251 r
(break)s
0 g
(;)s
(              })59.5 372.4 ms
(            })59.5 362.4 ms
(          })59.5 352.4 ms
(        })59.5 342.4 ms
(      })59.5 332.4 ms
(      done = )59.5 312.4 ms
0 0.251 0 r
(true)s
0 g
(;)s
(      )59.5 302.4 ms
0 0.125 0.251 r
(for)s
0 g
( \()s
0 0.251 0 r
(int)s
0 g
( j = )s
0 0.251 0 r
(0)s
0 g
(; j < Aggregate[i].nMolecules; j++\) {)s
(        )59.5 292.4 ms
0 0.125 0.251 r
(if)s
0 g
( \(!moved[j]\) {)s
(          done = )59.5 282.4 ms
0 0.251 0 r
(false)s
0 g
(;)s
(          )59.5 272.4 ms
0 0.125 0.251 r
(break)s
0 g
(;)s
(        })59.5 262.4 ms
(      })59.5 252.4 ms
(    })59.5 242.4 ms
(  })59.5 232.4 ms
(} )59.5 222.4 ms
F1 sf
0.251 0.251 0 r
(//}}})s
F0 sf
0 0.251 0 r
(int)59.5 202.4 ms
0 g
( main\()s
0 0.251 0 r
(int)s
0 g
( argc, )s
0 0.251 0 r
(char)s
0 g
( *argv[]\) {)s
(  )59.5 182.4 ms
F1 sf
0.251 0.251 0 r
(// -h option - print help and exit //{{{)s
F0 sf
0 g
(  )59.5 172.4 ms
0 0.125 0.251 r
(for)s
0 g
( \()s
0 0.251 0 r
(int)s
0 g
( i = )s
0 0.251 0 r
(1)s
0 g
(; i < argc; i++\) {)s
(    )59.5 162.4 ms
0 0.125 0.251 r
(if)s
0 g
( \(strcmp\(argv[i], )s
0 0.251 0 r
("-h")s
0 g
(\) == )s
0 0.251 0 r
(0)s
0 g
(\) {)s
(      printf\()59.5 152.4 ms
0 0.251 0 r
("Aggregates determines which molecules belong to which aggregate)s
0.376 0 0.376 r
(\\n)s
0 0.251 0 r
(")s
0 g
(\);)s
(      printf\()59.5 142.4 ms
0 0.251 0 r
("on the basis of given parameters - the minimum distance at which)s
0.376 0 0.376 r
(\\n)s
0 0.251 0 r
(")s
0 g
(\);)s
(      printf\()59.5 132.4 ms
0 0.251 0 r
("a pair of beads from different molecules is considered a contact;)s
0.376 0 0.376 r
(\\n)s
0 0.251 0 r
(")s
0 g
(\);)s
(      printf\()59.5 122.4 ms
0 0.251 0 r
("the minimum number of such contacts between two molecules to consider)s
0.376 0 0.376 r
(\\)s
(n)59.5 112.4 ms
0 0.251 0 r
(")s
0 g
(\);)s
(      printf\()59.5 102.4 ms
0 0.251 0 r
("them as belonging to the same aggregate. Only distances between)s
0.376 0 0.376 r
(\\n)s
0 0.251 0 r
(")s
0 g
(\);)s
(      printf\()59.5 92.4 ms
0 0.251 0 r
("specified bead types are considered. Information about aggregates)s
0.376 0 0.376 r
(\\n)s
0 0.251 0 r
(")s
0 g
(\);)s
(      printf\()59.5 82.4 ms
0 0.251 0 r
("in each timestep is written to .agg file. The program uses dl_meso.vsf)s
0.376 0 0.376 r
(\\n)59.5 72.4 ms
0 0.251 0 r
(")s
0 g
(\);)s
(      printf\()59.5 62.4 ms
0 0.251 0 r
("\(or other input structure file\) and FIELD \(along with optional)s
0.376 0 0.376 r
(\\n)s
0 0.251 0 r
(")s
0 g
(\);)s
(      printf\()59.5 52.4 ms
0 0.251 0 r
("bond file\) files to determine all information about the system.)s
0.376 0 0.376 r
(\\n\\n)s
0 0.251 0 r
(")s
0 g
(\);)s
re sp
%%PageTrailer
%%Page: 7 7
%%BeginPageSetup
sv
0 g
F0 sf
%%EndPageSetup
F1 sf
(Aggregates.c                                                                  Page 7)59.5 792.4 ms
F0 sf
(      printf\()59.5 762.4 ms
0 0.251 0 r
("Usage:)s
0.376 0 0.376 r
(\\n)s
0 0.251 0 r
(")s
0 g
(\);)s
(      printf\()59.5 752.4 ms
0 0.251 0 r
("   )s
0.376 0 0.376 r
(%s)s
0 0.251 0 r
( <input.vcf> <distance> <contacts> ")s
0 g
(, argv[)s
0 0.251 0 r
(0)s
0 g
(]\);)s
(      printf\()59.5 742.4 ms
0 0.251 0 r
("<output.agg> <type names> <options>)s
0.376 0 0.376 r
(\\n\\n)s
0 0.251 0 r
(")s
0 g
(\);)s
(      printf\()59.5 722.4 ms
0 0.251 0 r
("   <input.vcf>       input filename \(vcf format\))s
0.376 0 0.376 r
(\\n)s
0 0.251 0 r
(")s
0 g
(\);)s
(      printf\()59.5 712.4 ms
0 0.251 0 r
("   <output.agg>      output filename \(agg format\))s
0.376 0 0.376 r
(\\n)s
0 0.251 0 r
(")s
0 g
(\);)s
(      printf\()59.5 702.4 ms
0 0.251 0 r
("   <distance>        minimum distance for contact for aggregate check)s
0.376 0 0.376 r
(\\)s
(n)59.5 692.4 ms
0 0.251 0 r
(")s
0 g
(\);)s
(      printf\()59.5 682.4 ms
0 0.251 0 r
("   <contacts>        minimum number of contacts for aggregate check)s
0.376 0 0.376 r
(\\n)s
0 0.251 0 r
(")s
0 g
(\);)59.5 672.4 ms
(      printf\()59.5 662.4 ms
0 0.251 0 r
("   <type names>      names of bead types for closeness calculation)s
0.376 0 0.376 r
(\\n)s
0 0.251 0 r
(")s
0 g
(\))s
(;)59.5 652.4 ms
(      printf\()59.5 642.4 ms
0 0.251 0 r
("   <options>)s
0.376 0 0.376 r
(\\n)s
0 0.251 0 r
(")s
0 g
(\);)s
(      printf\()59.5 632.4 ms
0 0.251 0 r
("      -i <name>      use input .vsf file different from dl_meso.vsf)s
0.376 0 0.376 r
(\\n)s
0 0.251 0 r
(")s
0 g
(\);)59.5 622.4 ms
(      printf\()59.5 612.4 ms
0 0.251 0 r
("      -b <name>      file containing bond alternatives to FIELD)s
0.376 0 0.376 r
(\\n)s
0 0.251 0 r
(")s
0 g
(\);)s
(      printf\()59.5 602.4 ms
0 0.251 0 r
("      -v             verbose output)s
0.376 0 0.376 r
(\\n)s
0 0.251 0 r
(")s
0 g
(\);)s
(      printf\()59.5 592.4 ms
0 0.251 0 r
("      -V             verbose output with comments from input .vcf file)s
0.376 0 0.376 r
(\\n)59.5 582.4 ms
0 0.251 0 r
(")s
0 g
(\);)s
(      printf\()59.5 572.4 ms
0 0.251 0 r
("      -h             print this help and exit)s
0.376 0 0.376 r
(\\n)s
0 0.251 0 r
(")s
0 g
(\);)s
(      exit\()59.5 562.4 ms
0 0.251 0 r
(0)s
0 g
(\);)s
(    })59.5 552.4 ms
(  } )59.5 542.4 ms
F1 sf
0.251 0.251 0 r
(//}}})s
F0 sf
0 g
(  )59.5 522.4 ms
F1 sf
0.251 0.251 0 r
(// print command to stdout //{{{)s
F0 sf
0 g
(  )59.5 512.4 ms
0 0.125 0.251 r
(for)s
0 g
( \()s
0 0.251 0 r
(int)s
0 g
( i = )s
0 0.251 0 r
(0)s
0 g
(; i < argc; i++\))s
(    printf\()59.5 502.4 ms
0 0.251 0 r
(" )s
0.376 0 0.376 r
(%s)s
0 0.251 0 r
(")s
0 g
(, argv[i]\);)s
(  printf\()59.5 492.4 ms
0 0.251 0 r
(")s
0.376 0 0.376 r
(\\n\\n)s
0 0.251 0 r
(")s
0 g
(\); )s
F1 sf
0.251 0.251 0 r
(//}}})s
F0 sf
0 g
(  )59.5 472.4 ms
F1 sf
0.251 0.251 0 r
(// check if correct number of arguments //{{{)s
F0 sf
0 g
(  )59.5 462.4 ms
0 0.125 0.251 r
(if)s
0 g
( \(argc < )s
0 0.251 0 r
(6)s
0 g
(\) {)s
(    fprintf\()59.5 452.4 ms
0 0.251 0 r
(stderr)s
0 g
(, )s
0 0.251 0 r
("Too little arguments!)s
0.376 0 0.376 r
(\\n\\n)s
0 0.251 0 r
(")s
0 g
(\);)s
(    ErrorHelp\(argv[)59.5 442.4 ms
0 0.251 0 r
(0)s
0 g
(]\);)s
(    exit\()59.5 432.4 ms
0 0.251 0 r
(1)s
0 g
(\);)s
(  } )59.5 422.4 ms
F1 sf
0.251 0.251 0 r
(//}}})s
F0 sf
0 g
(  )59.5 402.4 ms
F1 sf
0.251 0.251 0 r
(// -i <name> option - filename of input structure file //{{{)s
F0 sf
0 g
(  )59.5 392.4 ms
0 0.251 0 r
(char)s
0 g
( vsf_file[)s
0 0.251 0 r
(32)s
0 g
(];)s
(  vsf_file[)59.5 382.4 ms
0 0.251 0 r
(0)s
0 g
(] = )s
0.376 0 0.376 r
('\\0')s
0 g
(; )s
F1 sf
0.251 0.251 0 r
(// check if -i option is used)s
F0 sf
0 g
(  )59.5 372.4 ms
0 0.125 0.251 r
(for)s
0 g
( \()s
0 0.251 0 r
(int)s
0 g
( i = )s
0 0.251 0 r
(1)s
0 g
(; i < argc; i++\) {)s
(    )59.5 362.4 ms
0 0.125 0.251 r
(if)s
0 g
( \(strcmp\(argv[i], )s
0 0.251 0 r
("-i")s
0 g
(\) == )s
0 0.251 0 r
(0)s
0 g
(\) {)s
(      )59.5 342.4 ms
F1 sf
0.251 0.251 0 r
(// wrong argument to -i option)s
F0 sf
0 g
(      )59.5 332.4 ms
0 0.125 0.251 r
(if)s
0 g
( \(\(i+)s
0 0.251 0 r
(1)s
0 g
(\) >= argc || argv[i+)s
0 0.251 0 r
(1)s
0 g
(][)s
0 0.251 0 r
(0)s
0 g
(] == )s
0 0.251 0 r
('-')s
0 g
(\) {)s
(        fprintf\()59.5 322.4 ms
0 0.251 0 r
(stderr)s
0 g
(, )s
0 0.251 0 r
(")s
0.376 0 0.376 r
(\\n)s
0 0.251 0 r
(Missing argument to '-i' option ")s
0 g
(\);)s
(        fprintf\()59.5 312.4 ms
0 0.251 0 r
(stderr)s
0 g
(, )s
0 0.251 0 r
("\(or filename beginning with a dash\)!)s
0.376 0 0.376 r
(\\n)s
0 0.251 0 r
(")s
0 g
(\);)s
(        exit\()59.5 302.4 ms
0 0.251 0 r
(1)s
0 g
(\);)s
(      })59.5 292.4 ms
(      )59.5 272.4 ms
F1 sf
0.251 0.251 0 r
(// check if .vsf ending is present)s
F0 sf
0 g
(      )59.5 262.4 ms
0 0.251 0 r
(char)s
0 g
( *vsf = strrchr\(argv[i+)s
0 0.251 0 r
(1)s
0 g
(], )s
0 0.251 0 r
('.')s
0 g
(\);)s
(      )59.5 252.4 ms
0 0.125 0.251 r
(if)s
0 g
( \(!vsf || strcmp\(vsf, )s
0 0.251 0 r
(".vsf")s
0 g
(\)\) {)s
(        fprintf\()59.5 242.4 ms
0 0.251 0 r
(stderr)s
0 g
(, )s
0 0.251 0 r
("'-i' arguments does not have .vsf ending!)s
0.376 0 0.376 r
(\\n)s
0 0.251 0 r
(")s
0 g
(\);)s
(        ErrorHelp\(argv[)59.5 232.4 ms
0 0.251 0 r
(0)s
0 g
(]\);)s
(        exit\()59.5 222.4 ms
0 0.251 0 r
(1)s
0 g
(\);)s
(      })59.5 212.4 ms
(      strcpy\(vsf_file, argv[i+)59.5 192.4 ms
0 0.251 0 r
(1)s
0 g
(]\);)s
(    })59.5 182.4 ms
(  })59.5 172.4 ms
(  )59.5 152.4 ms
F1 sf
0.251 0.251 0 r
(// -i option is not used)s
F0 sf
0 g
(  )59.5 142.4 ms
0 0.125 0.251 r
(if)s
0 g
( \(vsf_file[)s
0 0.251 0 r
(0)s
0 g
(] == )s
0.376 0 0.376 r
('\\0')s
0 g
(\) {)s
(    strcpy\(vsf_file, )59.5 132.4 ms
0 0.251 0 r
("dl_meso.vsf")s
0 g
(\);)s
(  } )59.5 122.4 ms
F1 sf
0.251 0.251 0 r
(//}}})s
F0 sf
0 g
(  )59.5 102.4 ms
F1 sf
0.251 0.251 0 r
(// -b <name> option - filename of input bond file //{{{)s
F0 sf
0 g
(  )59.5 92.4 ms
0 0.251 0 r
(char)s
0 g
( bonds_file[)s
0 0.251 0 r
(32)s
0 g
(];)s
(  bonds_file[)59.5 82.4 ms
0 0.251 0 r
(0)s
0 g
(] = )s
0.376 0 0.376 r
('\\0')s
0 g
(; )s
F1 sf
0.251 0.251 0 r
(// check if -b option is used)s
F0 sf
0 g
(  )59.5 72.4 ms
0 0.125 0.251 r
(for)s
0 g
( \()s
0 0.251 0 r
(int)s
0 g
( i = )s
0 0.251 0 r
(1)s
0 g
(; i < argc; i++\) {)s
(    )59.5 62.4 ms
0 0.125 0.251 r
(if)s
0 g
( \(strcmp\(argv[i], )s
0 0.251 0 r
("-b")s
0 g
(\) == )s
0 0.251 0 r
(0)s
0 g
(\) {)s
re sp
%%PageTrailer
%%Page: 8 8
%%BeginPageSetup
sv
0 g
F0 sf
%%EndPageSetup
F1 sf
(Aggregates.c                                                                  Page 8)59.5 792.4 ms
F0 sf
(      )59.5 772.4 ms
F1 sf
0.251 0.251 0 r
(// wrong argument to -i option)s
F0 sf
0 g
(      )59.5 762.4 ms
0 0.125 0.251 r
(if)s
0 g
( \(\(i+)s
0 0.251 0 r
(1)s
0 g
(\) >= argc || argv[i+)s
0 0.251 0 r
(1)s
0 g
(][)s
0 0.251 0 r
(0)s
0 g
(] == )s
0 0.251 0 r
('-')s
0 g
(\) {)s
(        fprintf\()59.5 752.4 ms
0 0.251 0 r
(stderr)s
0 g
(, )s
0 0.251 0 r
(")s
0.376 0 0.376 r
(\\n)s
0 0.251 0 r
(Missing argument to '-b' option ")s
0 g
(\);)s
(        fprintf\()59.5 742.4 ms
0 0.251 0 r
(stderr)s
0 g
(, )s
0 0.251 0 r
("\(or filename beginning with a dash\)!)s
0.376 0 0.376 r
(\\n\\n)s
0 0.251 0 r
(")s
0 g
(\);)s
(        ErrorHelp\(argv[)59.5 732.4 ms
0 0.251 0 r
(0)s
0 g
(]\);)s
(        exit\()59.5 722.4 ms
0 0.251 0 r
(1)s
0 g
(\);)s
(      })59.5 712.4 ms
(      strcpy\(bonds_file, argv[i+)59.5 692.4 ms
0 0.251 0 r
(1)s
0 g
(]\);)s
(    })59.5 682.4 ms
(  } )59.5 672.4 ms
F1 sf
0.251 0.251 0 r
(//}}})s
F0 sf
0 g
(  )59.5 652.4 ms
F1 sf
0.251 0.251 0 r
(// -v option - verbose output //{{{)s
F0 sf
0 g
(  )59.5 642.4 ms
0 0.251 0 r
(bool)s
0 g
( verbose = )s
0 0.251 0 r
(false)s
0 g
(;)s
(  )59.5 632.4 ms
0 0.125 0.251 r
(for)s
0 g
( \()s
0 0.251 0 r
(int)s
0 g
( i = )s
0 0.251 0 r
(1)s
0 g
(; i < argc; i++\) {)s
(    )59.5 622.4 ms
0 0.125 0.251 r
(if)s
0 g
( \(strcmp\(argv[i], )s
0 0.251 0 r
("-v")s
0 g
(\) == )s
0 0.251 0 r
(0)s
0 g
(\) {)s
(      verbose = )59.5 612.4 ms
0 0.251 0 r
(true)s
0 g
(;)s
(      )59.5 592.4 ms
0 0.125 0.251 r
(break)s
0 g
(;)s
(    })59.5 582.4 ms
(  } )59.5 572.4 ms
F1 sf
0.251 0.251 0 r
(//}}})s
F0 sf
0 g
(  )59.5 552.4 ms
F1 sf
0.251 0.251 0 r
(// -V option - verbose output with comments from input .vcf file //{{{)s
F0 sf
0 g
(  )59.5 542.4 ms
0 0.251 0 r
(bool)s
0 g
( verbose2 = )s
0 0.251 0 r
(false)s
0 g
(;)s
(  )59.5 532.4 ms
0 0.125 0.251 r
(for)s
0 g
( \()s
0 0.251 0 r
(int)s
0 g
( i = )s
0 0.251 0 r
(1)s
0 g
(; i < argc; i++\) {)s
(    )59.5 522.4 ms
0 0.125 0.251 r
(if)s
0 g
( \(strcmp\(argv[i], )s
0 0.251 0 r
("-V")s
0 g
(\) == )s
0 0.251 0 r
(0)s
0 g
(\) {)s
(      verbose = )59.5 512.4 ms
0 0.251 0 r
(true)s
0 g
(;)s
(      verbose2 = )59.5 502.4 ms
0 0.251 0 r
(true)s
0 g
(;)s
(      )59.5 482.4 ms
0 0.125 0.251 r
(break)s
0 g
(;)s
(    })59.5 472.4 ms
(  } )59.5 462.4 ms
F1 sf
0.251 0.251 0 r
(//}}})s
F0 sf
0 g
(  )59.5 442.4 ms
0 0.251 0 r
(int)s
0 g
( count = )s
0 0.251 0 r
(0)s
0 g
(; )s
F1 sf
0.251 0.251 0 r
(// count mandatory arguments)s
F0 sf
0 g
(  )59.5 422.4 ms
F1 sf
0.251 0.251 0 r
(// <input.vcf> - filename of input vcf file \(must end with .vcf\) //{{{)s
F0 sf
0 g
(  )59.5 412.4 ms
0 0.251 0 r
(char)s
0 g
( input_vcf[)s
0 0.251 0 r
(32)s
0 g
(];)s
(  strcpy\(input_vcf, argv[++count]\);)59.5 402.4 ms
(  )59.5 382.4 ms
F1 sf
0.251 0.251 0 r
(// test if <input.vcf> filename ends with '.vsf' \(required by VMD\))s
F0 sf
0 g
(  )59.5 372.4 ms
0 0.251 0 r
(char)s
0 g
( *dot = strrchr\(input_vcf, )s
0 0.251 0 r
('.')s
0 g
(\);)s
(  )59.5 362.4 ms
0 0.125 0.251 r
(if)s
0 g
( \(!dot || strcmp\(dot, )s
0 0.251 0 r
(".vcf")s
0 g
(\)\) {)s
(    fprintf\()59.5 352.4 ms
0 0.251 0 r
(stderr)s
0 g
(, )s
0 0.251 0 r
("<input.vcf> ')s
0.376 0 0.376 r
(%s)s
0 0.251 0 r
(' does not have .vcf ending!)s
0.376 0 0.376 r
(\\n)s
0 0.251 0 r
(")s
0 g
(, input_vcf\);)s
(    ErrorHelp\(argv[)59.5 342.4 ms
0 0.251 0 r
(0)s
0 g
(]\);)s
(    exit\()59.5 332.4 ms
0 0.251 0 r
(1)s
0 g
(\);)s
(  } )59.5 322.4 ms
F1 sf
0.251 0.251 0 r
(//}}})s
F0 sf
0 g
(  )59.5 302.4 ms
F1 sf
0.251 0.251 0 r
(// <distance> - number of starting timestep //{{{)s
F0 sf
0 g
(  )59.5 292.4 ms
F1 sf
0.251 0.251 0 r
(// Error - non-numeric argument)s
F0 sf
0 g
(  )59.5 282.4 ms
0 0.125 0.251 r
(if)s
0 g
( \(argv[++count][)s
0 0.251 0 r
(0)s
0 g
(] < )s
0 0.251 0 r
('0')s
0 g
( || argv[count][)s
0 0.251 0 r
(0)s
0 g
(] > )s
0 0.251 0 r
('9')s
0 g
(\) {)s
(    fprintf\()59.5 272.4 ms
0 0.251 0 r
(stderr)s
0 g
(, )s
0 0.251 0 r
("Non-numeric argement for <start>!)s
0.376 0 0.376 r
(\\n)s
0 0.251 0 r
(")s
0 g
(\);)s
(    ErrorHelp\(argv[)59.5 262.4 ms
0 0.251 0 r
(0)s
0 g
(]\);)s
(    exit\()59.5 252.4 ms
0 0.251 0 r
(1)s
0 g
(\);)s
(  })59.5 242.4 ms
(  )59.5 232.4 ms
0 0.251 0 r
(double)s
0 g
( distance = atof\(argv[count]\); )s
F1 sf
0.251 0.251 0 r
(//}}})s
F0 sf
0 g
(  )59.5 212.4 ms
F1 sf
0.251 0.251 0 r
(// <contacts> - number of steps to skip per one used //{{{)s
F0 sf
0 g
(  )59.5 202.4 ms
F1 sf
0.251 0.251 0 r
(// Error - non-numeric argument)s
F0 sf
0 g
(  )59.5 192.4 ms
0 0.125 0.251 r
(if)s
0 g
( \(argv[++count][)s
0 0.251 0 r
(0)s
0 g
(] < )s
0 0.251 0 r
('0')s
0 g
( || argv[count][)s
0 0.251 0 r
(0)s
0 g
(] > )s
0 0.251 0 r
('9')s
0 g
(\) {)s
(    fprintf\()59.5 182.4 ms
0 0.251 0 r
(stderr)s
0 g
(, )s
0 0.251 0 r
("Non-numeric argement for <skip>!)s
0.376 0 0.376 r
(\\n)s
0 0.251 0 r
(")s
0 g
(\);)s
(    ErrorHelp\(argv[)59.5 172.4 ms
0 0.251 0 r
(0)s
0 g
(]\);)s
(    exit\()59.5 162.4 ms
0 0.251 0 r
(1)s
0 g
(\);)s
(  })59.5 152.4 ms
(  )59.5 142.4 ms
0 0.251 0 r
(int)s
0 g
( contacts = atoi\(argv[count]\); )s
F1 sf
0.251 0.251 0 r
(//}}})s
F0 sf
0 g
(  )59.5 122.4 ms
F1 sf
0.251 0.251 0 r
(// <output.agg> - filename of output agg file \(must end with .agg\) //{{{)s
F0 sf
0 g
(  )59.5 112.4 ms
0 0.251 0 r
(char)s
0 g
( output_agg[)s
0 0.251 0 r
(32)s
0 g
(];)s
(  strcpy\(output_agg, argv[++count]\);)59.5 102.4 ms
(  )59.5 82.4 ms
F1 sf
0.251 0.251 0 r
(// test if <output.agg> filename ends with '.agg' \(required by VMD\))s
F0 sf
0 g
(  dot = strrchr\(output_agg, )59.5 72.4 ms
0 0.251 0 r
('.')s
0 g
(\);)s
(  )59.5 62.4 ms
0 0.125 0.251 r
(if)s
0 g
( \(!dot || strcmp\(dot, )s
0 0.251 0 r
(".agg")s
0 g
(\)\) {)s
(    fprintf\()59.5 52.4 ms
0 0.251 0 r
(stderr)s
0 g
(, )s
0 0.251 0 r
("<output.agg> ')s
0.376 0 0.376 r
(%s)s
0 0.251 0 r
(' does not have .agg ending!)s
0.376 0 0.376 r
(\\n)s
0 0.251 0 r
(")s
0 g
(, output_agg\);)s
re sp
%%PageTrailer
%%Page: 9 9
%%BeginPageSetup
sv
0 g
F0 sf
%%EndPageSetup
F1 sf
(Aggregates.c                                                                  Page 9)59.5 792.4 ms
F0 sf
(    ErrorHelp\(argv[)59.5 772.4 ms
0 0.251 0 r
(0)s
0 g
(]\);)s
(    exit\()59.5 762.4 ms
0 0.251 0 r
(1)s
0 g
(\);)s
(  } )59.5 752.4 ms
F1 sf
0.251 0.251 0 r
(//}}})s
F0 sf
0 g
(  )59.5 732.4 ms
F1 sf
0.251 0.251 0 r
(// variables - structures //{{{)s
F0 sf
0 g
(  BeadType *BeadType; )59.5 722.4 ms
F1 sf
0.251 0.251 0 r
(// structure with info about all bead types)s
F0 sf
0 g
(  MoleculeType *MoleculeType; )59.5 712.4 ms
F1 sf
0.251 0.251 0 r
(// structure with info about all molecule types)s
F0 sf
0 g
(  Bead *Bead; )59.5 702.4 ms
F1 sf
0.251 0.251 0 r
(// structure with info about every bead)s
F0 sf
0 g
(  Molecule *Molecule; )59.5 692.4 ms
F1 sf
0.251 0.251 0 r
(// structure with info about every molecule)s
F0 sf
0 g
(  Counts Counts; )59.5 682.4 ms
F1 sf
0.251 0.251 0 r
(// structure with number of beads, molecules, etc. //}}})s
F0 sf
0 g
(  )59.5 662.4 ms
F1 sf
0.251 0.251 0 r
(// read system information)s
F0 sf
0 g
(  )59.5 652.4 ms
0 0.251 0 r
(bool)s
0 g
( indexed = ReadStructure\(vsf_file, input_vcf, bonds_file, &Counts, &BeadType, )s
(&Bead, &MoleculeType, &Molecule\);)59.5 642.4 ms
(  )59.5 622.4 ms
F1 sf
0.251 0.251 0 r
(// <type names> - names of bead types to use for closeness calculation //{{{)s
F0 sf
0 g
(  )59.5 612.4 ms
0 0.125 0.251 r
(while)s
0 g
( \(++count < argc && argv[count][)s
0 0.251 0 r
(0)s
0 g
(] != )s
0 0.251 0 r
('-')s
0 g
(\) {)s
(    )59.5 602.4 ms
0 0.251 0 r
(int)s
0 g
( type = FindType\(argv[count], Counts, BeadType\);)s
(    )59.5 582.4 ms
F1 sf
0.251 0.251 0 r
(// Error - specified bead type name not in vcf input file)s
F0 sf
0 g
(    )59.5 572.4 ms
0 0.125 0.251 r
(if)s
0 g
( \(type == -)s
0 0.251 0 r
(1)s
0 g
(\) {)s
(      fprintf\()59.5 562.4 ms
0 0.251 0 r
(stderr)s
0 g
(, )s
0 0.251 0 r
("Bead type ')s
0.376 0 0.376 r
(%s)s
0 0.251 0 r
(' is not in )s
0.376 0 0.376 r
(%s)s
0 0.251 0 r
( coordinate file!)s
0.376 0 0.376 r
(\\n)s
0 0.251 0 r
(")s
0 g
(, argv[count],)s
( input_vcf\);)59.5 552.4 ms
(      exit\()59.5 542.4 ms
0 0.251 0 r
(1)s
0 g
(\);)s
(    })59.5 532.4 ms
(    BeadType[type].Use = )59.5 512.4 ms
0 0.251 0 r
(true)s
0 g
(;)s
(  } )59.5 502.4 ms
F1 sf
0.251 0.251 0 r
(//}}})s
F0 sf
0 g
(  )59.5 482.4 ms
F1 sf
0.251 0.251 0 r
(// print information - verbose output //{{{)s
F0 sf
0 g
(  )59.5 472.4 ms
0 0.125 0.251 r
(if)s
0 g
( \(verbose\) {)s
(    printf\()59.5 462.4 ms
0 0.251 0 r
(")s
0.376 0 0.376 r
(\\n)s
0 0.251 0 r
(   Read from FIELD)s
0.376 0 0.376 r
(\\n)s
0 0.251 0 r
(")s
0 g
(\);)s
(    printf\()59.5 452.4 ms
0 0.251 0 r
("Counts.{")s
0 g
(\);)s
(    printf\()59.5 442.4 ms
0 0.251 0 r
("TypesOfBeads =)s
0.376 0 0.376 r
(%3d)s
0 0.251 0 r
(, ")s
0 g
(, Counts.TypesOfBeads\);)s
(    printf\()59.5 432.4 ms
0 0.251 0 r
("Bonded =)s
0.376 0 0.376 r
(%7d)s
0 0.251 0 r
(, ")s
0 g
(, Counts.Bonded\);)s
(    printf\()59.5 422.4 ms
0 0.251 0 r
("Unboded =)s
0.376 0 0.376 r
(%7d)s
0 0.251 0 r
(, ")s
0 g
(, Counts.Unbonded\);)s
(    printf\()59.5 412.4 ms
0 0.251 0 r
("TypesOfMolecules =)s
0.376 0 0.376 r
(%3d)s
0 0.251 0 r
(, ")s
0 g
(, Counts.TypesOfMolecules\);)s
(    printf\()59.5 402.4 ms
0 0.251 0 r
("Molecules =)s
0.376 0 0.376 r
(%4d)s
0 0.251 0 r
(})s
0.376 0 0.376 r
(\\n)s
0 0.251 0 r
(")s
0 g
(, Counts.Molecules\);)s
(    printf\()59.5 392.4 ms
0 0.251 0 r
(")s
0.376 0 0.376 r
(\\n)s
0 0.251 0 r
(total number of beads: )s
0.376 0 0.376 r
(%d\\n\\n)s
0 0.251 0 r
(")s
0 g
(, Counts.Bonded+Counts.Unbonded\);)s
(    )59.5 372.4 ms
0 0.125 0.251 r
(for)s
0 g
( \()s
0 0.251 0 r
(int)s
0 g
( i = )s
0 0.251 0 r
(0)s
0 g
(; i < Counts.TypesOfBeads; i++\) {)s
(      printf\()59.5 362.4 ms
0 0.251 0 r
("BeadType[)s
0.376 0 0.376 r
(%2d)s
0 0.251 0 r
(].{")s
0 g
(, i\);)s
(      printf\()59.5 352.4 ms
0 0.251 0 r
("Name =)s
0.376 0 0.376 r
(%10s)s
0 0.251 0 r
(, ")s
0 g
(, BeadType[i].Name\);)s
(      printf\()59.5 342.4 ms
0 0.251 0 r
("Number =)s
0.376 0 0.376 r
(%7d)s
0 0.251 0 r
(, ")s
0 g
(, BeadType[i].Number\);)s
(      printf\()59.5 332.4 ms
0 0.251 0 r
("Charge =)s
0.376 0 0.376 r
(%6.2f)s
0 0.251 0 r
(, ")s
0 g
(, BeadType[i].Charge\);)s
(      printf\()59.5 322.4 ms
0 0.251 0 r
("Mass =)s
0.376 0 0.376 r
(%5.2f)s
0 0.251 0 r
(, ")s
0 g
(, BeadType[i].Mass\);)s
(      printf\()59.5 312.4 ms
0 0.251 0 r
("Use = )s
0.376 0 0.376 r
(%s)s
0 0.251 0 r
(})s
0.376 0 0.376 r
(\\n)s
0 0.251 0 r
(")s
0 g
(, BeadType[i].Use ? )s
0 0.251 0 r
("True")s
0 g
( : )s
0 0.251 0 r
("False")s
0 g
(\);)s
(    })59.5 302.4 ms
(    putchar\()59.5 292.4 ms
0.376 0 0.376 r
('\\n')s
0 g
(\);)s
(    )59.5 272.4 ms
0 0.125 0.251 r
(for)s
0 g
( \()s
0 0.251 0 r
(int)s
0 g
( i = )s
0 0.251 0 r
(0)s
0 g
(; i < Counts.TypesOfMolecules; i++\) {)s
(      printf\()59.5 262.4 ms
0 0.251 0 r
("MoleculeType[)s
0.376 0 0.376 r
(%d)s
0 0.251 0 r
(].{")s
0 g
(, i\);)s
(      printf\()59.5 252.4 ms
0 0.251 0 r
("Name =)s
0.376 0 0.376 r
(%10s)s
0 0.251 0 r
(")s
0 g
(, MoleculeType[i].Name\);)s
(      printf\()59.5 242.4 ms
0 0.251 0 r
(", Number =)s
0.376 0 0.376 r
(%4d)s
0 0.251 0 r
(")s
0 g
(, MoleculeType[i].Number\);)s
(      printf\()59.5 232.4 ms
0 0.251 0 r
(", nBeads =)s
0.376 0 0.376 r
(%3d)s
0 0.251 0 r
(")s
0 g
(, MoleculeType[i].nBeads\);)s
(      printf\()59.5 222.4 ms
0 0.251 0 r
(", nBonds =)s
0.376 0 0.376 r
(%3d)s
0 0.251 0 r
(")s
0 g
(, MoleculeType[i].nBonds\);)s
(      )59.5 212.4 ms
0 0.125 0.251 r
(if)s
0 g
( \(bonds_file[)s
0 0.251 0 r
(0)s
0 g
(] == )s
0.376 0 0.376 r
('\\0')s
0 g
(\) { )s
F1 sf
0.251 0.251 0 r
(// all bonds taken from FIELD)s
F0 sf
0 g
(        printf\()59.5 202.4 ms
0 0.251 0 r
(", Bonds from 'FIELD'})s
0.376 0 0.376 r
(\\n)s
0 0.251 0 r
(")s
0 g
(\);)s
(      } )59.5 192.4 ms
0 0.125 0.251 r
(else)s
0 g
( {)s
(        )59.5 182.4 ms
F1 sf
0.251 0.251 0 r
(// go through bond file to find out if molecule type 'i' is there)s
F0 sf
0 g
(        )59.5 172.4 ms
0 0.251 0 r
(FILE)s
0 g
( *bond;)s
(        )59.5 162.4 ms
0 0.125 0.251 r
(if)s
0 g
( \(\(bond = fopen\(bonds_file, )s
0 0.251 0 r
("r")s
0 g
(\)\) == )s
0 0.251 0 r
(NULL)s
0 g
(\) {)s
(          fprintf\()59.5 152.4 ms
0 0.251 0 r
(stderr)s
0 g
(, )s
0 0.251 0 r
("Cannot open file )s
0.376 0 0.376 r
(%s)s
0 0.251 0 r
( with '-v' option!)s
0.376 0 0.376 r
(\\n)s
0 0.251 0 r
(")s
0 g
(, bonds_file\);)s
(          exit\()59.5 142.4 ms
0 0.251 0 r
(1)s
0 g
(\);)s
(        })59.5 132.4 ms
(        )59.5 112.4 ms
0 0.251 0 r
(int)s
0 g
( test;)s
(        )59.5 102.4 ms
0 0.251 0 r
(char)s
0 g
( str[)s
0 0.251 0 r
(32)s
0 g
(];)s
(        )59.5 92.4 ms
0 0.125 0.251 r
(while)s
0 g
( \(\(test = getc\(bond\)\) != )s
0 0.251 0 r
(EOF)s
0 g
(\) {)s
(          ungetc\(test, bond\);)59.5 82.4 ms
(          )59.5 62.4 ms
0 0.125 0.251 r
(if)s
0 g
( \(\(fscanf\(bond, )s
0 0.251 0 r
(")s
0.376 0 0.376 r
(%s)s
0 0.251 0 r
( )s
0.376 0 0.376 r
(%d)s
0 0.251 0 r
(")s
0 g
(, str, &test\)\) != )s
0 0.251 0 r
(2)s
0 g
(\) {)s
(            fprintf\()59.5 52.4 ms
0 0.251 0 r
(stderr)s
0 g
(, )s
0 0.251 0 r
("Cannot read string or number of bonds from )s
0.376 0 0.376 r
(%s)s
0 0.251 0 r
( with '-v')s
re sp
%%PageTrailer
%%Page: 10 10
%%BeginPageSetup
sv
0 g
F0 sf
%%EndPageSetup
F1 sf
(Aggregates.c                                                                 Page 10)59.5 792.4 ms
F0 sf
0 0.251 0 r
( option!)59.5 772.4 ms
0.376 0 0.376 r
(\\n)s
0 0.251 0 r
(")s
0 g
(, bonds_file\);)s
(            exit\()59.5 762.4 ms
0 0.251 0 r
(1)s
0 g
(\);)s
(          })59.5 752.4 ms
(          )59.5 732.4 ms
0 0.125 0.251 r
(if)s
0 g
( \(strcmp\(str, MoleculeType[i].Name\) == )s
0 0.251 0 r
(0)s
0 g
(\) {)s
(            printf\()59.5 722.4 ms
0 0.251 0 r
(", Bonds from ')s
0.376 0 0.376 r
(%s)s
0 0.251 0 r
('})s
0.376 0 0.376 r
(\\n)s
0 0.251 0 r
(")s
0 g
(, bonds_file\);)s
(            )59.5 712.4 ms
0 0.125 0.251 r
(break)s
0 g
(;)s
(          })59.5 702.4 ms
(          )59.5 682.4 ms
0 0.125 0.251 r
(while)s
0 g
( \(getc\(bond\) != )s
0.376 0 0.376 r
('\\n')s
0 g
(\))s
(            ;)59.5 672.4 ms
(        })59.5 662.4 ms
(        )59.5 642.4 ms
F1 sf
0.251 0.251 0 r
(// if not in bonds_file, then bonds taken from FIELD)s
F0 sf
0 g
(        )59.5 632.4 ms
0 0.125 0.251 r
(if)s
0 g
( \(test == )s
0 0.251 0 r
(EOF)s
0 g
(\) {)s
(          printf\()59.5 622.4 ms
0 0.251 0 r
(", Bonds from 'FIELD'})s
0.376 0 0.376 r
(\\n)s
0 0.251 0 r
(")s
0 g
(\);)s
(        })59.5 612.4 ms
(        fclose\(bond\);)59.5 592.4 ms
(      })59.5 582.4 ms
(    })59.5 572.4 ms
(    printf\()59.5 552.4 ms
0 0.251 0 r
(")s
0.376 0 0.376 r
(\\n)s
0 0.251 0 r
(   Distance for closeness check: )s
0.376 0 0.376 r
(%lf\\n)s
0 0.251 0 r
(")s
0 g
(, distance\);)s
(    printf\()59.5 542.4 ms
0 0.251 0 r
("   Number of needed contacts for aggregate check: )s
0.376 0 0.376 r
(%d\\n)s
0 0.251 0 r
(")s
0 g
(, contacts\);)s
(  } )59.5 532.4 ms
F1 sf
0.251 0.251 0 r
(//}}})s
F0 sf
0 g
(  )59.5 512.4 ms
F1 sf
0.251 0.251 0 r
(// print command to output .agg file //{{{)s
F0 sf
0 g
(  )59.5 502.4 ms
0 0.251 0 r
(FILE)s
0 g
( *out;)s
(  )59.5 492.4 ms
0 0.125 0.251 r
(if)s
0 g
( \(\(out = fopen\(output_agg, )s
0 0.251 0 r
("w")s
0 g
(\)\) == )s
0 0.251 0 r
(NULL)s
0 g
(\) {)s
(    fprintf\()59.5 482.4 ms
0 0.251 0 r
(stderr)s
0 g
(, )s
0 0.251 0 r
("Cannot open file )s
0.376 0 0.376 r
(%s)s
0 0.251 0 r
(!)s
0.376 0 0.376 r
(\\n)s
0 0.251 0 r
(")s
0 g
(, output_agg\);)s
(    exit\()59.5 472.4 ms
0 0.251 0 r
(1)s
0 g
(\);)s
(  })59.5 462.4 ms
(  )59.5 442.4 ms
F1 sf
0.251 0.251 0 r
(// print command to stdout)s
F0 sf
0 g
(  )59.5 432.4 ms
0 0.125 0.251 r
(for)s
0 g
( \()s
0 0.251 0 r
(int)s
0 g
( i = )s
0 0.251 0 r
(0)s
0 g
(; i < argc; i++\))s
(    fprintf\(out, )59.5 422.4 ms
0 0.251 0 r
(" )s
0.376 0 0.376 r
(%s)s
0 0.251 0 r
(")s
0 g
(, argv[i]\);)s
(  putc\()59.5 412.4 ms
0.376 0 0.376 r
('\\n')s
0 g
(, out\);)s
(  fclose\(out\); )59.5 392.4 ms
F1 sf
0.251 0.251 0 r
(//}}})s
F0 sf
0 g
(  )59.5 372.4 ms
F1 sf
0.251 0.251 0 r
(// open input coordinate file //{{{)s
F0 sf
0 g
(  )59.5 362.4 ms
0 0.251 0 r
(FILE)s
0 g
( *vcf;)s
(  )59.5 352.4 ms
0 0.125 0.251 r
(if)s
0 g
( \(\(vcf = fopen\(input_vcf, )s
0 0.251 0 r
("r")s
0 g
(\)\) == )s
0 0.251 0 r
(NULL)s
0 g
(\) {)s
(    fprintf\()59.5 342.4 ms
0 0.251 0 r
(stderr)s
0 g
(, )s
0 0.251 0 r
("Cannot open file )s
0.376 0 0.376 r
(%s)s
0 0.251 0 r
(!)s
0.376 0 0.376 r
(\\n)s
0 0.251 0 r
(")s
0 g
(, input_vcf\);)s
(    exit\()59.5 332.4 ms
0 0.251 0 r
(1)s
0 g
(\);)s
(  } )59.5 322.4 ms
F1 sf
0.251 0.251 0 r
(//}}})s
F0 sf
0 g
(  )59.5 302.4 ms
F1 sf
0.251 0.251 0 r
(// get pbc from coordinate file //{{{)s
F0 sf
0 g
(  )59.5 292.4 ms
0 0.251 0 r
(char)s
0 g
( str[)s
0 0.251 0 r
(32)s
0 g
(];)s
(  )59.5 282.4 ms
F1 sf
0.251 0.251 0 r
(// skip till 'pbc' keyword)s
F0 sf
0 g
(  )59.5 272.4 ms
0 0.125 0.251 r
(do)s
0 g
( {)s
(    )59.5 262.4 ms
0 0.125 0.251 r
(if)s
0 g
( \(fscanf\(vcf, )s
0 0.251 0 r
(")s
0.376 0 0.376 r
(%s)s
0 0.251 0 r
(")s
0 g
(, str\) != )s
0 0.251 0 r
(1)s
0 g
(\) {)s
(      fprintf\()59.5 252.4 ms
0 0.251 0 r
(stderr)s
0 g
(, )s
0 0.251 0 r
("Cannot read string from ')s
0.376 0 0.376 r
(%s)s
0 0.251 0 r
(' file!)s
0.376 0 0.376 r
(\\n)s
0 0.251 0 r
(")s
0 g
(, input_vcf\);)s
(    })59.5 242.4 ms
(  } )59.5 232.4 ms
0 0.125 0.251 r
(while)s
0 g
( \(strcmp\(str, )s
0 0.251 0 r
("pbc")s
0 g
(\) != )s
0 0.251 0 r
(0)s
0 g
(\);)s
(  )59.5 212.4 ms
F1 sf
0.251 0.251 0 r
(// read pbc)s
F0 sf
0 g
(  Vector BoxLength;)59.5 202.4 ms
(  )59.5 192.4 ms
0 0.125 0.251 r
(if)s
0 g
( \(fscanf\(vcf, )s
0 0.251 0 r
(")s
0.376 0 0.376 r
(%lf)s
0 0.251 0 r
( )s
0.376 0 0.376 r
(%lf)s
0 0.251 0 r
( )s
0.376 0 0.376 r
(%lf)s
0 0.251 0 r
(")s
0 g
(, &BoxLength.x, &BoxLength.y, &BoxLength.z\) != )s
0 0.251 0 r
(3)s
0 g
(\) {)s
(    fprintf\()59.5 182.4 ms
0 0.251 0 r
(stderr)s
0 g
(, )s
0 0.251 0 r
("Cannot read pbc from )s
0.376 0 0.376 r
(%s)s
0 0.251 0 r
(!)s
0.376 0 0.376 r
(\\n)s
0 0.251 0 r
(")s
0 g
(, input_vcf\);)s
(    exit\()59.5 172.4 ms
0 0.251 0 r
(1)s
0 g
(\);)s
(  })59.5 162.4 ms
(  )59.5 142.4 ms
F1 sf
0.251 0.251 0 r
(// skip remainder of pbc line)s
F0 sf
0 g
(  )59.5 132.4 ms
0 0.125 0.251 r
(while)s
0 g
( \(getc\(vcf\) != )s
0.376 0 0.376 r
('\\n')s
0 g
(\))s
(    ;)59.5 122.4 ms
(  )59.5 112.4 ms
F1 sf
0.251 0.251 0 r
(// skip blank line)s
F0 sf
0 g
(  )59.5 102.4 ms
0 0.125 0.251 r
(while)s
0 g
( \(getc\(vcf\) != )s
0.376 0 0.376 r
('\\n')s
0 g
(\))s
(    ;)59.5 92.4 ms
(  )59.5 72.4 ms
F1 sf
0.251 0.251 0 r
(// print pbc if verbose output)s
F0 sf
0 g
(  )59.5 62.4 ms
0 0.125 0.251 r
(if)s
0 g
( \(verbose\) {)s
(    printf\()59.5 52.4 ms
0 0.251 0 r
("   box size: )s
0.376 0 0.376 r
(%lf)s
0 0.251 0 r
( x )s
0.376 0 0.376 r
(%lf)s
0 0.251 0 r
( x )s
0.376 0 0.376 r
(%lf\\n\\n)s
0 0.251 0 r
(")s
0 g
(, BoxLength.x, BoxLength.y, BoxLength.z)s
re sp
%%PageTrailer
%%Page: 11 11
%%BeginPageSetup
sv
0 g
F0 sf
%%EndPageSetup
F1 sf
(Aggregates.c                                                                 Page 11)59.5 792.4 ms
F0 sf
(\);)59.5 772.4 ms
(  } )59.5 762.4 ms
F1 sf
0.251 0.251 0 r
(//}}})s
F0 sf
0 g
(  )59.5 742.4 ms
F1 sf
0.251 0.251 0 r
(// create array for the first line of a timestep \('# <number and/or other comment>)s
('\) //{{{)59.5 732.4 ms
F0 sf
0 g
(  )59.5 722.4 ms
0 0.251 0 r
(char)s
0 g
( *stuff;)s
(  stuff = malloc\()59.5 712.4 ms
0 0.251 0 r
(128)s
0 g
(*)s
0 0.125 0.251 r
(sizeof)s
0 g
(\()s
0 0.251 0 r
(int)s
0 g
(\)\);)s
(  )59.5 692.4 ms
F1 sf
0.251 0.251 0 r
(// initialize the array)s
F0 sf
0 g
(  )59.5 682.4 ms
0 0.125 0.251 r
(for)s
0 g
( \()s
0 0.251 0 r
(int)s
0 g
( i = )s
0 0.251 0 r
(0)s
0 g
(; i < )s
0 0.251 0 r
(128)s
0 g
(; i++\) {)s
(    stuff[i] = )59.5 672.4 ms
0.376 0 0.376 r
('\\0')s
0 g
(;)s
(  } )59.5 662.4 ms
F1 sf
0.251 0.251 0 r
(//}}})s
F0 sf
0 g
(  )59.5 642.4 ms
F1 sf
0.251 0.251 0 r
(// allocate Aggregate struct //{{{)s
F0 sf
0 g
(  Aggregate *Aggregate = calloc\(Counts.Molecules,)59.5 632.4 ms
0 0.125 0.251 r
(sizeof)s
0 g
(\(*Aggregate\)\);)s
(  )59.5 622.4 ms
0 0.125 0.251 r
(for)s
0 g
( \()s
0 0.251 0 r
(int)s
0 g
( i = )s
0 0.251 0 r
(0)s
0 g
(; i < Counts.Molecules; i++\) {)s
(    )59.5 612.4 ms
F1 sf
0.251 0.251 0 r
(// assumes all monomeric beads can be near one aggregate - memory-heavy, but rel)s
(iable)59.5 602.4 ms
F0 sf
0 g
(    Aggregate[i].Monomer = calloc\(Counts.Unbonded,)59.5 592.4 ms
0 0.125 0.251 r
(sizeof)s
0 g
(\()s
0 0.251 0 r
(int)s
0 g
(\)\);)s
(    )59.5 582.4 ms
F1 sf
0.251 0.251 0 r
(// assumes all bonded beads can be in one aggregate - memory-heavy, but reliable)s
F0 sf
0 g
(    Aggregate[i].Bead = calloc\(Counts.Bonded,)59.5 572.4 ms
0 0.125 0.251 r
(sizeof)s
0 g
(\()s
0 0.251 0 r
(int)s
0 g
(\)\);)s
(    )59.5 562.4 ms
F1 sf
0.251 0.251 0 r
(// maximum of all molecules can be in one aggregate)s
F0 sf
0 g
(    Aggregate[i].Molecule = calloc\(Counts.Molecules,)59.5 552.4 ms
0 0.125 0.251 r
(sizeof)s
0 g
(\()s
0 0.251 0 r
(int)s
0 g
(\)\);)s
(  } )59.5 542.4 ms
F1 sf
0.251 0.251 0 r
(//}}})s
F0 sf
0 g
(  )59.5 522.4 ms
0 0.251 0 r
(FILE)s
0 g
( *test_vcf;)s
(  test_vcf = fopen\()59.5 512.4 ms
0 0.251 0 r
("test3.vcf")s
0 g
(, )s
0 0.251 0 r
("w")s
0 g
(\);)s
(  )59.5 502.4 ms
0 0.125 0.251 r
(for)s
0 g
( \()s
0 0.251 0 r
(int)s
0 g
( i = )s
0 0.251 0 r
(0)s
0 g
(; i < Counts.TypesOfBeads; i++\) {)s
(    fprintf\(test_vcf, )59.5 492.4 ms
0 0.251 0 r
("# )s
0.376 0 0.376 r
(%s\\n)s
0 0.251 0 r
(")s
0 g
(, BeadType[i].Name\);)s
(  })59.5 482.4 ms
(  fprintf\(test_vcf, )59.5 472.4 ms
0 0.251 0 r
(")s
0.376 0 0.376 r
(\\n)s
0 0.251 0 r
(pbc )s
0.376 0 0.376 r
(%lf)s
0 0.251 0 r
( )s
0.376 0 0.376 r
(%lf)s
0 0.251 0 r
( )s
0.376 0 0.376 r
(%lf\\n)s
0 0.251 0 r
(")s
0 g
(, BoxLength.x, BoxLength.y, BoxLength.z\);)s
(  )59.5 452.4 ms
F1 sf
0.251 0.251 0 r
(// main loop //{{{)s
F0 sf
0 g
(  count = )59.5 442.4 ms
0 0.251 0 r
(0)s
0 g
(; )s
F1 sf
0.251 0.251 0 r
(// count timesteps)s
F0 sf
0 g
(  )59.5 432.4 ms
0 0.251 0 r
(int)s
0 g
( test;)s
(  )59.5 422.4 ms
0 0.125 0.251 r
(while)s
0 g
( \(\(test = getc\(vcf\)\) != )s
0 0.251 0 r
(EOF)s
0 g
(\) {)s
(    ungetc\(test, vcf\);)59.5 412.4 ms
(    fflush\()59.5 392.4 ms
0 0.251 0 r
(stdout)s
0 g
(\);)s
(    printf\()59.5 382.4 ms
0 0.251 0 r
(")s
0.376 0 0.376 r
(\\r)s
0 0.251 0 r
(Step: )s
0.376 0 0.376 r
(%6d)s
0 0.251 0 r
(")s
0 g
(, ++count\);)s
(    )59.5 362.4 ms
F1 sf
0.251 0.251 0 r
(// read indexed timestep from input .vcf file //{{{)s
F0 sf
0 g
(    )59.5 352.4 ms
0 0.125 0.251 r
(if)s
0 g
( \(indexed\) {)s
(      )59.5 342.4 ms
0 0.125 0.251 r
(if)s
0 g
( \(\(test = ReadCoorIndexed\(vcf, Counts, &Bead, &stuff\)\) != )s
0 0.251 0 r
(0)s
0 g
(\) {)s
(        fprintf\()59.5 332.4 ms
0 0.251 0 r
(stderr)s
0 g
(, )s
0 0.251 0 r
("Cannot read coordinates from )s
0.376 0 0.376 r
(%s)s
0 0.251 0 r
(! \()s
0.376 0 0.376 r
(%d)s
0 0.251 0 r
(. step; )s
0.376 0 0.376 r
(%d)s
0 0.251 0 r
(. bead\))s
0.376 0 0.376 r
(\\n)s
0 0.251 0 r
(")s
0 g
(, i)s
(nput_vcf, count, test\);)59.5 322.4 ms
(        exit\()59.5 312.4 ms
0 0.251 0 r
(1)s
0 g
(\);)s
(      } )59.5 302.4 ms
F1 sf
0.251 0.251 0 r
(//}}})s
F0 sf
0 g
(    )59.5 292.4 ms
F1 sf
0.251 0.251 0 r
(// or read ordered timestep from input .vcf file //{{{)s
F0 sf
0 g
(    } )59.5 282.4 ms
0 0.125 0.251 r
(else)s
0 g
( {)s
(      )59.5 272.4 ms
0 0.125 0.251 r
(if)s
0 g
( \(\(test = ReadCoorOrdered\(vcf, Counts, &Bead, &stuff\)\) != )s
0 0.251 0 r
(0)s
0 g
(\) {)s
(        fprintf\()59.5 262.4 ms
0 0.251 0 r
(stderr)s
0 g
(, )s
0 0.251 0 r
("Cannot read coordinates from )s
0.376 0 0.376 r
(%s)s
0 0.251 0 r
(! \()s
0.376 0 0.376 r
(%d)s
0 0.251 0 r
(. step; )s
0.376 0 0.376 r
(%d)s
0 0.251 0 r
(. bead\))s
0.376 0 0.376 r
(\\n)s
0 0.251 0 r
(")s
0 g
(, i)s
(nput_vcf, count, test\);)59.5 252.4 ms
(        exit\()59.5 242.4 ms
0 0.251 0 r
(1)s
0 g
(\);)s
(      })59.5 232.4 ms
(    } )59.5 222.4 ms
F1 sf
0.251 0.251 0 r
(//}}})s
F0 sf
0 g
(    CalculateAggregates\(&Aggregate, &Counts, SQR\(distance\), contacts, BoxLength, Bea)59.5 202.4 ms
(dType, &Bead, MoleculeType, Molecule\);)59.5 192.4 ms
(    )59.5 172.4 ms
0 0.125 0.251 r
(for)s
0 g
( \()s
0 0.251 0 r
(int)s
0 g
( i = )s
0 0.251 0 r
(0)s
0 g
(; i < Counts.Molecules; i++\) {)s
(      )59.5 162.4 ms
0 0.251 0 r
(int)s
0 g
( type = Molecule[i].Type;)s
(      )59.5 152.4 ms
0 0.125 0.251 r
(for)s
0 g
( \()s
0 0.251 0 r
(int)s
0 g
( j = )s
0 0.251 0 r
(0)s
0 g
(; j < MoleculeType[type].nBonds; j++\) {)s
(        )59.5 142.4 ms
0 0.251 0 r
(int)s
0 g
( id1 = Molecule[i].Bead[MoleculeType[type].Bond[j][)s
0 0.251 0 r
(0)s
0 g
(]];)s
(        )59.5 132.4 ms
0 0.251 0 r
(int)s
0 g
( id2 = Molecule[i].Bead[MoleculeType[type].Bond[j][)s
0 0.251 0 r
(1)s
0 g
(]];)s
(        Vector dist = DistanceBetweenBeads\(id1, id2, Bead, BoxLength\);)59.5 112.4 ms
(        Bead[id2].Position.x = Bead[id1].Position.x - dist.x;)59.5 92.4 ms
(        Bead[id2].Position.y = Bead[id1].Position.y - dist.y;)59.5 82.4 ms
(        Bead[id2].Position.z = Bead[id1].Position.z - dist.z;)59.5 72.4 ms
(      })59.5 62.4 ms
(    })59.5 52.4 ms
re sp
%%PageTrailer
%%Page: 12 12
%%BeginPageSetup
sv
0 g
F0 sf
%%EndPageSetup
F1 sf
(Aggregates.c                                                                 Page 12)59.5 792.4 ms
F0 sf
(    )59.5 762.4 ms
0 0.251 0 r
(bool)s
0 g
( done = )s
0 0.251 0 r
(false)s
0 g
(;)s
(    )59.5 752.4 ms
0 0.125 0.251 r
(while)s
0 g
( \(!done\) {)s
(    )59.5 742.4 ms
0 0.125 0.251 r
(for)s
0 g
( \()s
0 0.251 0 r
(int)s
0 g
( i = )s
0 0.251 0 r
(0)s
0 g
(; i < Counts.Aggregates; i++\) {)s
(      )59.5 722.4 ms
0 0.251 0 r
(bool)s
0 g
( moved[Counts.Molecules];)s
(      )59.5 702.4 ms
0 0.125 0.251 r
(for)s
0 g
( \()s
0 0.251 0 r
(int)s
0 g
( j = )s
0 0.251 0 r
(0)s
0 g
(; j < Counts.Molecules; j++\) {)s
(        moved[j] = )59.5 692.4 ms
0 0.251 0 r
(false)s
0 g
(;)s
(      })59.5 682.4 ms
(      moved[)59.5 672.4 ms
0 0.251 0 r
(0)s
0 g
(] = )s
0 0.251 0 r
(true)s
0 g
(;)s
(      )59.5 652.4 ms
F1 sf
0.251 0.251 0 r
(// go through all molecules in aggregate 'i')s
F0 sf
0 g
(      )59.5 642.4 ms
0 0.125 0.251 r
(for)s
0 g
( \()s
0 0.251 0 r
(int)s
0 g
( j = )s
0 0.251 0 r
(0)s
0 g
(; j < Aggregate[i].nMolecules; j++\) {)s
(        )59.5 632.4 ms
0 0.251 0 r
(int)s
0 g
( mol1 = Aggregate[i].Molecule[j];)s
(        )59.5 622.4 ms
F1 sf
0.251 0.251 0 r
(// go through all beads in molecule 'mol1' \(provided 'mol1' has been moved\))s
F0 sf
0 g
(        )59.5 612.4 ms
0 0.125 0.251 r
(for)s
0 g
( \()s
0 0.251 0 r
(int)s
0 g
( k = )s
0 0.251 0 r
(0)s
0 g
(; moved[j] && k < MoleculeType[Molecule[mol1].Type].nBeads; k+)s
(+\) {)59.5 602.4 ms
(          )59.5 592.4 ms
0 0.251 0 r
(int)s
0 g
( bead1 = Molecule[mol1].Bead[k];)s
(          )59.5 572.4 ms
F1 sf
0.251 0.251 0 r
(// go through all molecules again \(provided 'bead1' type is used for calcu)s
(lation\))59.5 562.4 ms
F0 sf
0 g
(          )59.5 552.4 ms
0 0.125 0.251 r
(for)s
0 g
( \()s
0 0.251 0 r
(int)s
0 g
( l = )s
0 0.251 0 r
(0)s
0 g
(; BeadType[Bead[bead1].Type].Use && l < Aggregate[i].nMolecu)s
(les; l++\) {)59.5 542.4 ms
(            )59.5 532.4 ms
0 0.251 0 r
(int)s
0 g
( mol2 = Aggregate[i].Molecule[l];)s
(            )59.5 522.4 ms
F1 sf
0.251 0.251 0 r
(// go through all beads in molecule 'mol2' \(provided 'mol2' hasn't been )s
(moved\))59.5 512.4 ms
F0 sf
0 g
(            )59.5 502.4 ms
0 0.125 0.251 r
(for)s
0 g
( \()s
0 0.251 0 r
(int)s
0 g
( m = )s
0 0.251 0 r
(0)s
0 g
(; !moved[l] && m < MoleculeType[Molecule[mol1].Type].nBead)s
(s; m++\) {)59.5 492.4 ms
(              )59.5 482.4 ms
0 0.251 0 r
(int)s
0 g
( bead2 = Molecule[mol2].Bead[m];)s
(              )59.5 462.4 ms
0 0.125 0.251 r
(if)s
0 g
( \(BeadType[Bead[bead2].Type].Use\) {)s
(                Vector dist = DistanceBetweenBeads\(bead1, bead2, Bead, BoxLength\);)59.5 442.4 ms
(                )59.5 432.4 ms
0 0.251 0 r
(double)s
0 g
( distance2 = sqrt\(SQR\(dist.x\) + SQR\(dist.y\) + SQR\(dist.z\)\);)s
(                )59.5 412.4 ms
0 0.125 0.251 r
(if)s
0 g
( \(distance2 <= distance\) {)s
(                  dist.x = Bead[bead1].Position.x - Bead[bead2].Position.x;)59.5 392.4 ms
(                  dist.y = Bead[bead1].Position.y - Bead[bead2].Position.y;)59.5 382.4 ms
(                  dist.z = Bead[bead1].Position.z - Bead[bead2].Position.z;)59.5 372.4 ms
(                  )59.5 352.4 ms
0 0.125 0.251 r
(if)s
0 g
( \(dist.x > \(BoxLength.x/)s
0 0.251 0 r
(2)s
0 g
(\)\) { )s
F1 sf
0.251 0.251 0 r
(//{{{)s
F0 sf
0 g
(                    )59.5 342.4 ms
0 0.125 0.251 r
(for)s
0 g
( \()s
0 0.251 0 r
(int)s
0 g
( n = )s
0 0.251 0 r
(0)s
0 g
(; n < MoleculeType[Molecule[mol2].Type].nBeads; n+)s
(+\) {)59.5 332.4 ms
(                      Bead[Molecule[mol2].Bead[n]].Position.x += BoxLength.x;)59.5 322.4 ms
(                    })59.5 312.4 ms
(                  } )59.5 302.4 ms
0 0.125 0.251 r
(else)s
0 g
( )s
0 0.125 0.251 r
(if)s
0 g
( \(dist.x <= -\(BoxLength.x/)s
0 0.251 0 r
(2)s
0 g
(\)\) {)s
(                    )59.5 292.4 ms
0 0.125 0.251 r
(for)s
0 g
( \()s
0 0.251 0 r
(int)s
0 g
( n = )s
0 0.251 0 r
(0)s
0 g
(; n < MoleculeType[Molecule[mol2].Type].nBeads; n+)s
(+\) {)59.5 282.4 ms
(                      Bead[Molecule[mol2].Bead[n]].Position.x -= BoxLength.x;)59.5 272.4 ms
(                    })59.5 262.4 ms
(                  } )59.5 252.4 ms
F1 sf
0.251 0.251 0 r
(//}}})s
F0 sf
0 g
(                  )59.5 232.4 ms
0 0.125 0.251 r
(if)s
0 g
( \(dist.y > \(BoxLength.y/)s
0 0.251 0 r
(2)s
0 g
(\)\) { )s
F1 sf
0.251 0.251 0 r
(//{{{)s
F0 sf
0 g
(                    )59.5 222.4 ms
0 0.125 0.251 r
(for)s
0 g
( \()s
0 0.251 0 r
(int)s
0 g
( n = )s
0 0.251 0 r
(0)s
0 g
(; n < MoleculeType[Molecule[mol2].Type].nBeads; n+)s
(+\) {)59.5 212.4 ms
(                      Bead[Molecule[mol2].Bead[n]].Position.y += BoxLength.y;)59.5 202.4 ms
(                    })59.5 192.4 ms
(                  } )59.5 182.4 ms
0 0.125 0.251 r
(else)s
0 g
( )s
0 0.125 0.251 r
(if)s
0 g
( \(dist.y <= -\(BoxLength.y/)s
0 0.251 0 r
(2)s
0 g
(\)\) {)s
(                    )59.5 172.4 ms
0 0.125 0.251 r
(for)s
0 g
( \()s
0 0.251 0 r
(int)s
0 g
( n = )s
0 0.251 0 r
(0)s
0 g
(; n < MoleculeType[Molecule[mol2].Type].nBeads; n+)s
(+\) {)59.5 162.4 ms
(                      Bead[Molecule[mol2].Bead[n]].Position.y -= BoxLength.y;)59.5 152.4 ms
(                    })59.5 142.4 ms
(                  } )59.5 132.4 ms
F1 sf
0.251 0.251 0 r
(//}}})s
F0 sf
0 g
(                  )59.5 112.4 ms
0 0.125 0.251 r
(if)s
0 g
( \(dist.z > \(BoxLength.z/)s
0 0.251 0 r
(2)s
0 g
(\)\) { )s
F1 sf
0.251 0.251 0 r
(//{{{)s
F0 sf
0 g
(                    )59.5 102.4 ms
0 0.125 0.251 r
(for)s
0 g
( \()s
0 0.251 0 r
(int)s
0 g
( n = )s
0 0.251 0 r
(0)s
0 g
(; n < MoleculeType[Molecule[mol2].Type].nBeads; n+)s
(+\) {)59.5 92.4 ms
(                      Bead[Molecule[mol2].Bead[n]].Position.z += BoxLength.z;)59.5 82.4 ms
(                    })59.5 72.4 ms
(                  } )59.5 62.4 ms
0 0.125 0.251 r
(else)s
0 g
( )s
0 0.125 0.251 r
(if)s
0 g
( \(dist.z <= -\(BoxLength.z/)s
0 0.251 0 r
(2)s
0 g
(\)\) {)s
(                    )59.5 52.4 ms
0 0.125 0.251 r
(for)s
0 g
( \()s
0 0.251 0 r
(int)s
0 g
( n = )s
0 0.251 0 r
(0)s
0 g
(; n < MoleculeType[Molecule[mol2].Type].nBeads; n+)s
re sp
%%PageTrailer
%%Page: 13 13
%%BeginPageSetup
sv
0 g
F0 sf
%%EndPageSetup
F1 sf
(Aggregates.c                                                                 Page 13)59.5 792.4 ms
F0 sf
(+\) {)59.5 772.4 ms
(                      Bead[Molecule[mol2].Bead[n]].Position.z -= BoxLength.z;)59.5 762.4 ms
(                    })59.5 752.4 ms
(                  } )59.5 742.4 ms
F1 sf
0.251 0.251 0 r
(//}}})s
F0 sf
0 g
(                  moved[l] = )59.5 722.4 ms
0 0.251 0 r
(true)s
0 g
(;)s
(                })59.5 712.4 ms
(              })59.5 702.4 ms
(            })59.5 692.4 ms
(          })59.5 682.4 ms
(        })59.5 672.4 ms
(      })59.5 662.4 ms
(      done = )59.5 642.4 ms
0 0.251 0 r
(true)s
0 g
(;)s
(      )59.5 632.4 ms
0 0.125 0.251 r
(for)s
0 g
( \()s
0 0.251 0 r
(int)s
0 g
( j = )s
0 0.251 0 r
(0)s
0 g
(; j < Aggregate[i].nMolecules; j++\) {)s
(        )59.5 622.4 ms
0 0.125 0.251 r
(if)s
0 g
( \(!moved[j]\) {)s
(          done = )59.5 612.4 ms
0 0.251 0 r
(false)s
0 g
(;)s
(        })59.5 602.4 ms
(      })59.5 592.4 ms
(    })59.5 582.4 ms
(    })59.5 572.4 ms
F1 sf
0.251 0.251 0 r
(//  RemovePBCAggregates\(Aggregate, Counts, BoxLength, BeadType, &Bead, MoleculeType,)59.5 552.4 ms
( Molecule\);)59.5 542.4 ms
F0 sf
0 g
(    )59.5 522.4 ms
0 0.251 0 r
(bool)s
0 g
( *backup = malloc\(Counts.TypesOfBeads*)s
0 0.125 0.251 r
(sizeof)s
0 g
(\()s
0 0.251 0 r
(bool)s
0 g
(\)\);)s
(    )59.5 512.4 ms
0 0.125 0.251 r
(for)s
0 g
( \()s
0 0.251 0 r
(int)s
0 g
( i = )s
0 0.251 0 r
(0)s
0 g
( ; i < Counts.TypesOfBeads; i++\) {)s
(      backup[i] = BeadType[i].Use;)59.5 502.4 ms
(      BeadType[i].Use = )59.5 492.4 ms
0 0.251 0 r
(true)s
0 g
(;)s
(    })59.5 482.4 ms
(    )59.5 472.4 ms
0 0.251 0 r
(char)s
0 g
( *stuff = calloc\()s
0 0.251 0 r
(1)s
0 g
(,)s
0 0.125 0.251 r
(sizeof)s
0 g
(\()s
0 0.251 0 r
(char)s
0 g
(\)\);)s
(    WriteCoorIndexed\(test_vcf, Counts, BeadType, Bead, stuff\);)59.5 462.4 ms
(    )59.5 452.4 ms
0 0.125 0.251 r
(for)s
0 g
( \()s
0 0.251 0 r
(int)s
0 g
( i = )s
0 0.251 0 r
(0)s
0 g
( ; i < Counts.TypesOfBeads; i++\) {)s
(      BeadType[i].Use = backup[i];)59.5 442.4 ms
(    })59.5 432.4 ms
(    free\(backup\);)59.5 422.4 ms
(    )59.5 402.4 ms
F1 sf
0.251 0.251 0 r
(// open output .agg file for appending //{{{)s
F0 sf
0 g
(    )59.5 392.4 ms
0 0.125 0.251 r
(if)s
0 g
( \(\(out = fopen\(output_agg, )s
0 0.251 0 r
("a")s
0 g
(\)\) == )s
0 0.251 0 r
(NULL)s
0 g
(\) {)s
(      fprintf\()59.5 382.4 ms
0 0.251 0 r
(stderr)s
0 g
(, )s
0 0.251 0 r
("Cannot open file )s
0.376 0 0.376 r
(%s)s
0 0.251 0 r
(!)s
0.376 0 0.376 r
(\\n)s
0 0.251 0 r
(")s
0 g
(, output_agg\);)s
(      exit\()59.5 372.4 ms
0 0.251 0 r
(1)s
0 g
(\);)s
(    } )59.5 362.4 ms
F1 sf
0.251 0.251 0 r
(//}}})s
F0 sf
0 g
(    )59.5 342.4 ms
F1 sf
0.251 0.251 0 r
(// write data to output .agg file //{{{)s
F0 sf
0 g
(    fprintf\(out, )59.5 332.4 ms
0 0.251 0 r
(")s
0.376 0 0.376 r
(\\n)s
0 0.251 0 r
(Step:)s
0.376 0 0.376 r
(%d\\n%d\\n\\n)s
0 0.251 0 r
(")s
0 g
(, count, Counts.Aggregates\);)s
(    )59.5 322.4 ms
0 0.251 0 r
(int)s
0 g
( test_count = )s
0 0.251 0 r
(0)s
0 g
(; )s
F1 sf
0.251 0.251 0 r
(// to test that all molecules are in aggregate)s
F0 sf
0 g
(    )59.5 302.4 ms
F1 sf
0.251 0.251 0 r
(// go through all aggregates)s
F0 sf
0 g
(    )59.5 292.4 ms
0 0.125 0.251 r
(for)s
0 g
( \()s
0 0.251 0 r
(int)s
0 g
( i = )s
0 0.251 0 r
(0)s
0 g
(; i < Counts.Aggregates; i++\) {)s
(      test_count += Aggregate[i].nMolecules;)59.5 272.4 ms
(      )59.5 252.4 ms
F1 sf
0.251 0.251 0 r
(// go through all molecules in aggregate 'i')s
F0 sf
0 g
(      fprintf\(out, )59.5 242.4 ms
0 0.251 0 r
(")s
0.376 0 0.376 r
(%d)s
0 0.251 0 r
( :")s
0 g
(, Aggregate[i].nMolecules\);)s
(      )59.5 232.4 ms
0 0.125 0.251 r
(for)s
0 g
( \()s
0 0.251 0 r
(int)s
0 g
( j = )s
0 0.251 0 r
(0)s
0 g
(; j < Aggregate[i].nMolecules; j++ \) {)s
(        fprintf\(out, )59.5 222.4 ms
0 0.251 0 r
(" )s
0.376 0 0.376 r
(%d)s
0 0.251 0 r
(")s
0 g
(, Aggregate[i].Molecule[j]+)s
0 0.251 0 r
(1)s
0 g
(\);)s
(      })59.5 212.4 ms
(      putc\()59.5 202.4 ms
0.376 0 0.376 r
('\\n')s
0 g
(, out\);)s
(      )59.5 182.4 ms
F1 sf
0.251 0.251 0 r
(// go through all monomeric beads in aggregate 'i')s
F0 sf
0 g
(      fprintf\(out, )59.5 172.4 ms
0 0.251 0 r
("   )s
0.376 0 0.376 r
(%d)s
0 0.251 0 r
( :")s
0 g
(, Aggregate[i].nMonomers\);)s
(      )59.5 162.4 ms
0 0.125 0.251 r
(for)s
0 g
( \()s
0 0.251 0 r
(int)s
0 g
( j = )s
0 0.251 0 r
(0)s
0 g
(; j < Aggregate[i].nMonomers; j++\) {)s
(        fprintf\(out, )59.5 152.4 ms
0 0.251 0 r
(" )s
0.376 0 0.376 r
(%d)s
0 0.251 0 r
(")s
0 g
(, Aggregate[i].Monomer[j]\);)s
(      })59.5 142.4 ms
(      putc\()59.5 132.4 ms
0.376 0 0.376 r
('\\n')s
0 g
(, out\);)s
(    })59.5 122.4 ms
(    )59.5 102.4 ms
0 0.125 0.251 r
(if)s
0 g
( \(test_count != Counts.Molecules\) {)s
(      fprintf\()59.5 92.4 ms
0 0.251 0 r
(stderr)s
0 g
(, )s
0 0.251 0 r
("Not all molecules were assigned to aggregates!)s
0.376 0 0.376 r
(\\n)s
0 0.251 0 r
(")s
0 g
(\);)s
(      fprintf\()59.5 82.4 ms
0 0.251 0 r
(stderr)s
0 g
(, )s
0 0.251 0 r
("Counts.Molecules = )s
0.376 0 0.376 r
(%5d)s
0 0.251 0 r
(; Molecules in aggregates: )s
0.376 0 0.376 r
(%d\\n)s
0 0.251 0 r
(")s
0 g
(, Count)s
(s.Molecules, test_count\);)59.5 72.4 ms
(      exit\()59.5 62.4 ms
0 0.251 0 r
(1)s
0 g
(\);)s
(    } )59.5 52.4 ms
F1 sf
0.251 0.251 0 r
(//}}})s
re sp
%%PageTrailer
%%Page: 14 14
%%BeginPageSetup
sv
0 g
F0 sf
%%EndPageSetup
F1 sf
(Aggregates.c                                                                 Page 14)59.5 792.4 ms
F0 sf
(    fclose\(out\);)59.5 762.4 ms
(    )59.5 742.4 ms
F1 sf
0.251 0.251 0 r
(// print comment at the beginning of a timestep - detailed verbose output //{{{)s
F0 sf
0 g
(    )59.5 732.4 ms
0 0.125 0.251 r
(if)s
0 g
( \(verbose2\) {)s
(      printf\()59.5 722.4 ms
0 0.251 0 r
(")s
0.376 0 0.376 r
(\\n%s)s
0 0.251 0 r
(")s
0 g
(, stuff\);)s
(    } )59.5 712.4 ms
F1 sf
0.251 0.251 0 r
(//}}})s
F0 sf
0 g
(  })59.5 702.4 ms
(  fclose\(vcf\);)59.5 682.4 ms
(  fflush\()59.5 662.4 ms
0 0.251 0 r
(stdout)s
0 g
(\);)s
(  printf\()59.5 652.4 ms
0 0.251 0 r
(")s
0.376 0 0.376 r
(\\r)s
0 0.251 0 r
(Last Step: )s
0.376 0 0.376 r
(%6d\\n)s
0 0.251 0 r
(")s
0 g
(, count\); )s
F1 sf
0.251 0.251 0 r
(//}}})s
F0 sf
0 g
(  )59.5 632.4 ms
F1 sf
0.251 0.251 0 r
(// free memory - to make valgrind happy //{{{)s
F0 sf
0 g
(  free\(BeadType\);)59.5 622.4 ms
(  )59.5 612.4 ms
0 0.125 0.251 r
(for)s
0 g
( \()s
0 0.251 0 r
(int)s
0 g
( i = )s
0 0.251 0 r
(0)s
0 g
(; i < Counts.TypesOfMolecules; i++\) {)s
(    )59.5 602.4 ms
0 0.125 0.251 r
(for)s
0 g
( \()s
0 0.251 0 r
(int)s
0 g
( j = )s
0 0.251 0 r
(0)s
0 g
(; j < MoleculeType[i].nBonds; j++\) {)s
(      free\(MoleculeType[i].Bond[j]\);)59.5 592.4 ms
(    })59.5 582.4 ms
(    free\(MoleculeType[i].Bond\);)59.5 572.4 ms
(  })59.5 562.4 ms
(  free\(MoleculeType\);)59.5 552.4 ms
(  free\(Bead\);)59.5 542.4 ms
(  )59.5 532.4 ms
0 0.125 0.251 r
(for)s
0 g
( \()s
0 0.251 0 r
(int)s
0 g
( i = )s
0 0.251 0 r
(0)s
0 g
(; i < Counts.Molecules; i++\) {)s
(    free\(Molecule[i].Bead\);)59.5 522.4 ms
(    free\(Aggregate[i].Molecule\);)59.5 502.4 ms
(    free\(Aggregate[i].Bead\);)59.5 492.4 ms
(    free\(Aggregate[i].Monomer\);)59.5 482.4 ms
(  })59.5 472.4 ms
(  free\(Molecule\);)59.5 462.4 ms
(  free\(Aggregate\);)59.5 452.4 ms
(  free\(stuff\);)59.5 442.4 ms
(  )59.5 432.4 ms
F1 sf
0.251 0.251 0 r
(//}}})s
F0 sf
0 g
(  )59.5 412.4 ms
0 0.125 0.251 r
(return)s
0 g
( )s
0 0.251 0 r
(0)s
0 g
(;)s
(})59.5 402.4 ms
re sp
%%PageTrailer
%%Trailer
%%Pages: 14
%%EOF
